created_by,created_date,deleted,description,job_id,json_content,lastmodifiedby,alias,lastmodifieddate,name,organization,type,version,tags,interfacetype,pipeline_metadata,is_template,is_app
"admin","2024-10-01 05:25:21.530000","\0","Flask app for Leo Chatbot",\N,"{""elements"":[{""id"":""VknlU"",""alias"":""create chat context object"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""create_chat_context_object"",""requirements"":"""",""params"":[],""script"":[""\\r# from leaputils.processoutputs import processOutput\\rimport os\\rimport logging as logger\\rimport json\\r\\rimport sys\\rimport mysql.connector\\rfrom langchain.chains.sql_database.query import create_sql_query_chain\\rfrom langchain_community.utilities.sql_database import SQLDatabase\\rfrom threading import Thread\\rfrom langchain_openai import AzureChatOpenAI\\rfrom langchain.agents import AgentExecutor, tool, create_structured_chat_agent\\rimport requests\\r\\rrequests.packages.urllib3.disable_warnings()\\rfrom langchain_core.prompts import PromptTemplate\\rimport logging\\rfrom langchain.memory import ConversationBufferMemory\\rimport certifi\\rfrom flask import Flask, jsonify, request\\rfrom flask_cors import CORS\\rimport uuid\\rimport os, time, json\\rfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder\\rfrom datetime import datetime\\rimport urllib.parse\\r\\rclass ChatContext:\\r    #: Unique chat session id\\r    chat_id: str = None\\r    #: Unique chat user id, to be derived from jwt implicitly once auth is implemented\\r    chat_user_id: str = None\\r    #: Context storage for the session\\r    chat_context: list[str] = None\\r    # User query\\r    chat_user_query: str = None\\r    #: AI chatbot response\\r    chat_system_response: str = None\\r    #: Send the user uploaded file in blob format\\r    chat_user_upload_file: object = None\\r    #: User uploaded file type\\r    chat_user_upload_file_type: str = None\\r    #: Response time for the chat in miliseconds\\r    chat_response_time: float = None\\r    #: RAI metric value\\r    chat_rai_metric: float = None\\r    #: Confidence score/ accuracy metric for the chat query response\\r    chat_confidence_score: float = None\\r    #: If chat response contain a file, populate it with the extention such as png, jpg, mp4, mp3\\r    chat_response_file_type: list[str] = None\\r    #: If chat response contain a file, populate it with the extention such as png, jpg, mp4, mp3\\r    chat_response_file_data: list[object] = None\\r\\rdef create_chat_context_object(chat_id, chat_user_id, chat_user_query, chat_system_response, chat_response_time):\\r    chat_context_obj = ChatContext()\\r    chat_context_obj.chat_id = chat_id\\r    chat_context_obj.chat_user_id = chat_user_id\\r    chat_context_obj.chat_user_query = chat_user_query\\r    chat_context_obj.chat_system_response = chat_system_response\\r    chat_context_obj.chat_response_time = chat_response_time\\r    return chat_context_obj\\r\\r\\rchat_context: ChatContext = ChatContext\\r\\rchat_history: dict = dict()""]},""position_x"":""445"",""position_y"":""171"",""connectors"":[],""inputEndpoints"":[""dataset1"",""dataset2"",""dataset3""],""outputEndpoints"":[""out""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n""},""context"":[]},{""id"":""EbpDp"",""alias"":""FlaskAPP"",""name"":""FlaskAPP"",""classname"":""FlaskAPP"",""category"":""FlaskAPP"",""attributes"":{""port"":""9893"",""script"":[""app = Flask(__name__)\\r\\rCORS(app)\\r\\r\\""\\""\\""Do chat. send the user query and get the response back\\r\\r\\""\\""\\""\\r\\r@app.route(\\""/api/chat\\"", methods=[\\""POST\\""])\\rdef do_chat():\\r    data = json.loads(request.get_data())\\r    chat_id = data.get('chat_id', None)\\r    if chat_id is None or chat_id == \\""\\"" or chat_id == \\""null\\"":\\r        chat_id = uuid.uuid4().hex\\r    chat_user_id = data.get('chat_user_id', None)\\r    if chat_user_id is None:\\r        raise ValueError(\\""Error: User ID not provided\\"")\\r    chat_user_query = data.get('chat_user_query')\\r    print(f\\""User Query: {chat_user_query}\\"")\\r    if chat_user_query.lower() == \\""main menu\\"":\\r        previous_chat_history = []\\r    else:\\r        previous_chat_history = chat_history.get(chat_id, [])\\r    memory = intialise_memory(previous_chat_history)\\r    chat_time = datetime.now().strftime(\\""%I:%M %p\\"")\\r    current_date = datetime.now().strftime(\\""%d-%b-%Y\\"")\\r    thread = Thread(target=db_start_chat_session, args=(chat_user_id, chat_id, str(chat_time), current_date))\\r    thread.start()\\r    start = time.time()\\r    chat_system_response_dict = get_chain_response(chat_user_query, memory)\\r    end = time.time()\\r    chat_response_time = (end - start) * 10 ** 3\\r    chat_system_response = chat_system_response_dict['chat_system_response']\\r    current_chat_context = create_chat_context_object(chat_id, chat_user_id, chat_user_query,\\r                                                      chat_system_response, chat_response_time)\\r    update_chat = chat_history.get(chat_id, [])\\r    update_chat.append(current_chat_context)\\r    chat_history[chat_id] = update_chat\\r\\r    response_time = datetime.now().strftime(\\""%I:%M %p\\"")\\r    thread = Thread(target=db_add_chat_question_response, args=(chat_id, chat_user_query, str(chat_time),\\r                                                                chat_system_response_dict['chat_chain_of_thoughts'],\\r                                                                chat_response_time,\\r                                                                chat_system_response, str(response_time)))\\r    thread.start()\\r    response = {\\r        \\""chat_id\\"": chat_id,\\r        \\""chat_user_id\\"": chat_user_id,\\r        \\""chat_response_time\\"": chat_response_time,\\r        \\""chat_chain_of_thoughts\\"": chat_system_response_dict['chat_chain_of_thoughts'],\\r        \\""Chat_time\\"": str(datetime.now())\\r    }\\r    response.update(chat_system_response_dict)\\r    return response\\r\\r\\r\\r\\r\\r@app.route(\\""/api/get_chat_intro\\"", methods=[\\""GET\\""])\\r\\rdef get_chat_intro():\\r\\r    try:\\r\\r        response_dict = dict()\\r\\r        response_dict[\\""chat_system_intro\\""] = \\""How may I help you \\""\\r\\r        response_dict[\\""chat_suggestions\\""] = [\\r\\r            {\\r\\r                \\""Options\\"":\\r\\r                    [\\r\\r                        \\""Process Tickets\\"", \\""Troubleshoot\\"", \\""Self Help\\"", \\""Knowledge Search\\""\\r\\r                    ]\\r\\r            }\\r\\r        ]\\r\\r        response = json.dumps(response_dict)\\r\\r        return response\\r\\r    except Exception as e:\\r\\r        app.logger.error(e)\\r\\r\\r\\r\\r\\r@app.route(\\""/api/getSessionChat\\"", methods=[\\""POST\\""])\\r\\rdef getSessionChat():\\r\\r    try:\\r\\r        data = json.loads(request.get_data())\\r\\r        session_id = data.get('chat_id', None)\\r\\r        chat_user_id = data.get('chat_user_id', None)\\r\\r        db_data = db_fetch_chat_session_records(chat_user_id, session_id)\\r\\r        num = 0\\r\\r        data = []\\r\\r        intro = json.loads(get_chat_intro())\\r\\r        for suggestion in intro[\\""chat_suggestions\\""]:\\r\\r            if \\""Options\\"" in suggestion:\\r\\r                suggestion[\\""Queries\\""] = suggestion.pop(\\""Options\\"")\\r\\r        intro[\\""chat_time\\""] = db_fetch_chat_time(session_id)\\r\\r        chat_intro = {\\r\\r            \\""chatbotIntro\\"":\\r\\r                intro\\r\\r        }\\r\\r        data.append(dict(chat_intro))\\r\\r        for i in db_data:\\r\\r            user = f\\""user{num}\\""\\r\\r            bot = f\\""bot{num + 1}\\""\\r\\r            num += 1\\r\\r            user_data = {\\r\\r                user: {\\r\\r                    \\""chat_id\\"": i['session_id'],\\r\\r                    \\""chat_user_query\\"": i['chat_user_query'],\\r\\r                    \\""chat_user_id\\"": 12,\\r\\r                    \\""chat_time\\"": i['query_time']\\r\\r                }\\r\\r            }\\r\\r            bot_data = {\\r\\r                bot: {\\r\\r                    \\""chat_chain_of_thoughts\\"": i['chat_chain_of_thoughts'],\\r\\r                    \\""chat_id\\"": i['session_id'],\\r\\r                    \\""chat_response_time\\"": i['chat_response_time'],\\r\\r                    \\""chat_system_response\\"": i['message'],\\r\\r                    \\""references\\"": i['references'],\\r\\r                    \\""chat_user_id\\"": 12,\\r\\r                    \\""chat_time\\"": i['response_time']\\r\\r                }\\r\\r            }\\r\\r            data.append(dict(user_data))\\r\\r            data.append(dict(bot_data))\\r\\r        return data\\r\\r    except Exception as e:\\r\\r        logger.error(f\\""Exception in history method: {e} \\"")\\r\\r\\r\\r\\r\\r@app.route(\\""/api/userChatHistory\\"", methods=[\\""POST\\""])\\r\\rdef get_user_chat_history():\\r\\r    try:\\r\\r        data = json.loads(request.get_data())\\r\\r        chat_user_id = data.get('chat_user_id', None)\\r\\r        result = db_get_user_chat_history(chat_user_id)\\r\\r        result = {'records': result}\\r\\r        return result\\r\\r    except Exception as e:\\r\\r        logger.error(f\\""Exception in get_User_Session method: {e} \\"")\\r\\r\\r@app.route('/healthCheck', methods=['GET'])\\r\\rdef healthCheck():\\r\\r    response = {'Instance': os.environ['LEAP_URL'],  'Project': Leap_Project_Name,\\r\\r                'Health': 'up', 'Chain': 'LeoChatbot', 'Job ID': \\""LEOLCHTB10964\\"", \\""Hosted On\\"": 'LocalCluster'}\\r\\r    return jsonify(response), 200""]},""position_x"":""622"",""position_y"":""309"",""connectors"":[],""inputEndpoints"":[""in""],""outputEndpoints"":[],""formats"":{""port"":""integer"",""script"":""textarea""},""codeGeneration"":{""imports"":[""from flask import Flask"",""from flask import jsonify"",""from flask import request"",""import openai""],""requirements"":[""flask""],""script"":""def FlaskAPP(port_param=5000,script_param=''):\\r\\n    app.run(debug=True, host='0.0.0.0', port = port_param)\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\n""},""context"":[]},{""id"":""lTghn"",""alias"":""Intialise Agent"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""intialise_memory"",""requirements"":"""",""params"":[],""script"":[""\\r\\r\\r\\rdef intialise_memory(previous_chat_history):\\r\\r\\r\\r    try:\\r\\r\\r\\r        print(\\""Initialising memory...........\\"")\\r\\r\\r\\r        memory = ConversationBufferMemory(memory_key=\\""chat_history\\"", return_messages=True, input_key=\\""input\\"",\\r\\r\\r\\r                                          output_key=\\""output\\"")\\r\\r\\r\\r        if len(previous_chat_history) > 0:\\r\\r\\r\\r            for context_obj in previous_chat_history:\\r\\r\\r\\r                ai_message = str(context_obj.chat_system_response)\\r\\r\\r\\r                memory.chat_memory.add_user_message(context_obj.chat_user_query)\\r\\r\\r\\r                memory.chat_memory.add_ai_message(ai_message)\\r\\r\\r\\r        return memory\\r\\r\\r\\r    except Exception as e:\\r\\r\\r\\r        logger.debug(f\\""Exception in initialise memory method: {e}\\"")\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\rsystem = '''Respond to the human as helpfully and accurately as possible. You have access to the following tools:\\r\\r{tools}\\r\\rUse a json blob to specify a tool by providing an action key (tool name) and an action_input key (tool input).\\r\\rValid \\""action\\"" values: \\""Final Answer\\"" or {tool_names}\\r\\rProvide only ONE action per $JSON_BLOB, as shown:\\r\\r```\\r\\r{{\\r\\r\\""action\\"": $TOOL_NAME,\\r\\r\\""action_input\\"": $INPUT\\r\\r}}\\r\\r```\\r\\rFollow this format:\\r\\rQuestion: input question to answer\\r\\rThought: consider previous responses and subsequent steps\\r\\rAction:\\r\\r```\\r\\r$JSON_BLOB\\r\\r```\\r\\rObservation: action result\\r\\r... (repeat Thought/Action/Observation N times)\\r\\rThought: I know what to respond\\r\\rAction:\\r\\r```\\r\\r{{\\r\\r\\""action\\"": \\""Final Answer\\"",\\r\\r\\""action_input\\"": \\""Final response to human\\""\\r\\r}}\\r\\rBegin! Reminder to ALWAYS respond with a valid json blob of a single action. \\r\\rYou should always try to use only the specified tools for the user's query.\\r\\r Do not ask for default parameters of tools.\\r\\r If the user asks to fetch or get something from database then don't convert the user query to SQL query just pass the\\r\\r  same natural language user query as the action_input. \\r\\r  If user provides important information such as role ID, system ID, case ID, knowledge base, ticket number save this information in memory and\\r\\r   use this information for subsequent user queries. \\r\\rPlease generate a response using only the defined tools available to you.\\r\\r Try to use knowledge search tool for an general queries. first ask the user for knowledge base and then ask for query. \\r\\r SAve knowledge base name in memory for subsequent questions.\\r\\r And whenever using knowledge search tool it should always have action_input with knowledge_base and query both as keys.\\r\\r If user query is just Knowledge Search then just use knowledge base without any query.\\r\\r don't generate random queries for knowledge search tool other than using exact given query.\\r\\r When user asks for main menu then clear the memory and start fresh\\r\\r\\r\\r Check all tools before responding if you are authorized for system admin tasks. You are authorized to do tasks like role assignment and password reset'''\\r\\rhuman = '''\\r\\r{input}\\r\\r{agent_scratchpad}\\r\\r(reminder to respond in a JSON blob no matter what)'''\\r\\r\\r\\rprompt = ChatPromptTemplate.from_messages(\\r\\r\\r\\r    [\\r\\r\\r\\r        (\\""system\\"", system),\\r\\r\\r\\r        MessagesPlaceholder(\\""chat_history\\"", optional=True),\\r\\r\\r\\r        (\\""human\\"", human),\\r\\r\\r\\r    ]\\r\\r\\r\\r)\\r\\r""]},""position_x"":""444"",""position_y"":""293"",""connectors"":[],""inputEndpoints"":[""dataset1"",""dataset2"",""dataset3""],""outputEndpoints"":[""out""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n""},""context"":[]},{""id"":""uxQll"",""alias"":""Get chain response"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""get_chain_response"",""requirements"":"""",""params"":[],""script"":[""\\r\\rdef get_chain_response(chat_user_query, memory):\\r\\r\\r\\r    # try:\\r\\r\\r\\r    chat_system_response = {}\\r\\r\\r\\r    Answer_dict = {}\\r\\r\\r\\r    chain_of_thoughts = []\\r\\r\\r\\r    tools = [fetch_tickets, fetch_tickets_recommendation, resolve_ticket, verify_ticket, url_navigator, password_reset,\\r\\r\\r\\r             role_assignment, fetch_alerts, get_case_status,enrich_ticket,\\r\\r\\r\\r             get_workflow_status, knowledge_search, related_tickets, related_ci, self_help, main_menu,create_ticket]  # sop_search\\r\\r\\r\\r    agent = create_structured_chat_agent(llm, tools, prompt)\\r\\r\\r\\r    agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True, return_intermediate_steps=True,\\r\\r\\r\\r                                   memory=memory, handle_parsing_errors=True)\\r\\r\\r\\r    try:\\r\\r        \\r\\r        print(f'agent executor has to be invoked...')\\r\\r        chat_system_response = agent_executor.invoke({\\""input\\"": chat_user_query})\\r\\r        print(f'agent executor has been invoked...')\\r\\r\\r\\r\\r\\r\\r\\r    except requests.RequestException as r:\\r\\r\\r\\r        # chat_system_response[\\""output\\""] = \\""API overloaded, please try again after sometime...\\""\\r\\r        chat_system_response[\\""output\\""] = str(r)\\r\\r        chat_system_response[\\""intermediate_steps\\""] = []\\r\\r\\r\\r    except Exception as e:\\r\\r\\r\\r        chat_system_response[\\""output\\""] = e\\r\\r\\r\\r        chat_system_response[\\""intermediate_steps\\""] = []\\r\\r\\r\\r    try:\\r\\r\\r\\r        Answer_dict = json.loads(chat_system_response[\\""output\\""])\\r\\r\\r\\r    except Exception as e:\\r\\r\\r\\r        if isinstance(chat_system_response[\\""output\\""], dict):\\r\\r\\r\\r            return chat_system_response[\\""output\\""]\\r\\r\\r\\r        else:\\r\\r\\r\\r            system_response = chat_system_response[\\""output\\""]\\r\\r\\r\\r            Answer_dict[\\""chat_system_response\\""] = system_response\\r\\r\\r\\r    if len(chat_system_response['intermediate_steps']) > 0:\\r\\r\\r\\r        temp_dict = dict(chat_system_response['intermediate_steps'][0][0])\\r\\r\\r\\r        value = temp_dict.get('tool', 'NA')\\r\\r\\r\\r        print(value)\\r\\r\\r\\r        # if \\""_Exception\\"" not in value:\\r\\r\\r\\r        tool_input = temp_dict.get('tool_input', {})\\r\\r\\r\\r        if type(tool_input) != str:\\r\\r\\r\\r            tool_input = json.dumps(tool_input)\\r\\r\\r\\r        response_dict = {\\r\\r\\r\\r            'tool': temp_dict.get('tool', 'NA'),\\r\\r\\r\\r            'tool_input': tool_input,\\r\\r\\r\\r            'observation': f\\""After understanding user query, I decided to use {temp_dict.get('tool', 'NA')} tool\\"",\\r\\r\\r\\r            'type': \\""AgentAction\\""\\r\\r\\r\\r        }\\r\\r\\r\\r        chain_of_thoughts.append(response_dict)\\r\\r\\r\\r        Answer_dict[\\""chat_chain_of_thoughts\\""] = chain_of_thoughts\\r\\r\\r\\r    else:\\r\\r\\r\\r        Answer_dict[\\""chat_chain_of_thoughts\\""] = \\""No tool has been used.\\""\\r\\r\\r\\r        return Answer_dict\\r\\r\\r\\r    return Answer_dict\\r\\r\\r\\r""]},""position_x"":""617"",""position_y"":""211"",""connectors"":[],""inputEndpoints"":[""dataset1"",""dataset2"",""dataset3""],""outputEndpoints"":[""out""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n""},""context"":[]},{""id"":""ywOgE"",""alias"":""Get adapter response"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""get_adapter_response"",""requirements"":"""",""params"":[],""script"":[""\\r\\rdef get_adapter_response(url, index=None, query=None, type=\\""post\\""):\\r\\r\\r\\r    '''\\r\\r\\r\\r    using this method to get the adapter response\\r\\r\\r\\r    '''\\r\\r\\r\\r    logger.debug(f\\"" get_adapter_response called with index{index}\\"")\\r\\r    print(f\\"" get_adapter_response called with index{index} and query {query}\\"")\\r\\r\\r\\r    header = {\\r\\r\\r\\r        'Accept': 'application/json, text/plain, */*',\\r\\r\\r\\r        'Content-Type': 'application/json',\\r\\r\\r\\r        'Project': str(Leap_Project_Id),\\r\\r\\r\\r        'ProjectName': Leap_Project_Name,\\r\\r\\r\\r        'Access-Token': os.environ['Leap_access_token'],\\r\\r\\r\\r    }\\r\\r\\r\\r    payload = {\\""query\\"": query, \\""index_name\\"": index}\\r\\r\\r\\r    if type == \\""post\\"":\\r\\r\\r\\r        try:\\r\\r\\r\\r            print(\\""Inside post resuest of get adapter response.\\"")\\r\\r\\r\\r            response = requests.post(url=url, headers=header, json=payload, verify=False)\\r\\r            print(\\""Got the response\\"")\\r\\r\\r\\r            # print(response)\\r\\r            print(response)\\r\\r\\r\\r            print(response.status_code)\\r\\r\\r\\r            if response.status_code == 200:\\r\\r\\r\\r                print(\\""Got the response\\"")\\r\\r\\r\\r                try:\\r\\r\\r\\r                    answer = json.loads(response.text)[0].get(\\""Answer\\"")\\r\\r\\r\\r                    return answer\\r\\r\\r\\r                except Exception as e:\\r\\r\\r\\r                    response = f\\""Error in parsing the response: {e}\\""\\r\\r                    print(response)\\r\\r\\r\\r                    return response\\r\\r\\r\\r            else:\\r\\r\\r\\r                response = f\\""The is an error in POST response, response status: {response.status_code}\\""\\r\\r\\r\\r                return response\\r\\r            \\r\\r        except Exception as e:\\r\\r            print(f\\""Exception in get adapter response post call: {e}\\"")\\r\\r\\r\\r    else:\\r\\r\\r\\r        print(\\""Inside else of get adapter response.\\"")\\r\\r\\r\\r        response = requests.get(url=url, verify=False)\\r\\r\\r\\r        logger.debug(f\\"" get_adapter_response returns {response}\\"")\\r\\r\\r\\r        print(response.status_code)\\r\\r\\r\\r        if response.status_code == 200:\\r\\r\\r\\r            return json.loads(response.text)\\r\\r\\r\\r        else:\\r\\r\\r\\r            response = f\\""The is an error in GET response, response status: {response.status_code}\\""\\r\\r\\r\\r            return response\\r\\r\\r\\r""]},""position_x"":""273"",""position_y"":""313"",""connectors"":[],""inputEndpoints"":[""dataset1"",""dataset2"",""dataset3""],""outputEndpoints"":[""out""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n""},""context"":[]},{""id"":""FYNTA"",""alias"":""Trigger EMF workflow"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""trigger_emf_workflow"",""requirements"":"""",""params"":[],""script"":[""\\r\\r"",""def trigger_emf_workflow(payload):\\r\\r"",""\\r\\r"",""    import requests\\r\\r"",""\\r\\r"",""    import json\\r\\r"",""\\r\\r"",""    url = Leap_URL+\\""/api/emf/triggerWorkflow\\""\\r\\r"",""\\r\\r"",""    payload = json.dumps(payload)\\r\\r"",""\\r\\r"",""    header = {\\r\\r"",""\\r\\r"",""        'Accept': 'application/json, text/plain, */*',\\r\\r"",""\\r\\r"",""        'Content-Type': 'application/json',\\r\\r"",""\\r\\r"",""        'Project': str(Leap_Project_Id),\\r\\r"",""\\r\\r"",""        'ProjectName': Leap_Project_Name,\\r\\r"",""\\r\\r"",""        'Access-Token': \\""bdbae31b-dbb9-498a-b930-623e6021552e\\"",\\r\\r"",""\\r\\r"",""    }\\r\\r"",""\\r\\r"",""    response = requests.request(\\""POST\\"", url, headers=header, data=payload, verify=False)\\r\\r"",""\\r\\r"",""    print(response.text)\\r\\r"",""\\r\\r"",""    if response.status_code == 202:\\r\\r"",""\\r\\r"",""        workflowInstanceid = json.loads(response.text)[\\""workflowInstanceId\\""]\\r\\r"",""\\r\\r"",""        workflowId = json.loads(response.text)[\\""workflowId\\""]\\r\\r"",""\\r\\r"",""    return workflowInstanceid, workflowId\\r\\r"",""\\r\\r""]},""position_x"":""275"",""position_y"":""73"",""connectors"":[],""inputEndpoints"":[""dataset1"",""dataset2"",""dataset3""],""outputEndpoints"":[""out""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n""},""context"":[]},{""id"":""WMUpQ"",""alias"":""Extract Tickets"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""icap_extract_tickets"",""requirements"":"""",""params"":[],""script"":[""def icap_extract_tickets(shortdescription):\\r\\r    url = os.environ[\\""ICAP_URL\\""]+\\""/api/Extractors/extract_tickets?applicationId=2\\""\\r\\r    logger.info(\\""Extracting Tickets\\"")\\r\\r    logger.info(shortdescription)\\r\\r    payload = json.dumps({\\r\\r        \\""shortDescription\\"": shortdescription,\\r\\r        \\""BotId\\"": \\""27\\""\\r\\r    })\\r\\r    headers = {\\r\\r        'Content-Type': 'application/json'\\r\\r    }\\r\\r\\r\\r    response = requests.request(\\""POST\\"", url, headers=headers, data=payload)\\r\\r\\r\\r    logger.info(response.text)""]},""position_x"":""92"",""position_y"":""120"",""connectors"":[],""inputEndpoints"":[""dataset1"",""dataset2"",""dataset3""],""outputEndpoints"":[""out""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n""},""context"":[]},{""id"":""bpUth"",""alias"":""Classify Ticket"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""icap_classify_ticket"",""requirements"":"""",""params"":[],""script"":[""def icap_classify_ticket(number):\\r\\r    url = os.environ[\\""ICAP_URL\\""]+\\""/api/Classifier/classify_ticket?applicationId=2\\""\\r\\r\\r\\r    payload = json.dumps({\\r\\r        \\""ticketId\\"": number\\r\\r    })\\r\\r    headers = {\\r\\r        'Content-Type': 'application/json'\\r\\r    }\\r\\r\\r\\r    response = requests.request(\\""POST\\"", url, headers=headers, data=payload)\\r\\r\\r\\r    print(response.text)\\r\\r    return response.text""]},""position_x"":""94"",""position_y"":""236"",""connectors"":[],""inputEndpoints"":[""dataset1"",""dataset2"",""dataset3""],""outputEndpoints"":[""out""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n""},""context"":[]},{""id"":""KGWQH"",""alias"":""Verify Ticket"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""icap_verify_ticket"",""requirements"":"""",""params"":[],""script"":[""def icap_verify_ticket(number):\\r    url = os.environ[\\""ICAP_URL\\""]+\\""/api/Classifier/verify_ticket?applicationId=2\\""\\r    payload = json.dumps({\\r        \\""ticketId\\"": number,\\r        \\""ManualVerificationNeeded\\"": \\""no\\""\\r    })\\r    headers = {\\r        'Content-Type': 'application/json'\\r    }\\r\\r    response = requests.request(\\""POST\\"", url, headers=headers, data=payload)\\r\\r    print(response.text)\\r\\r    return response.text""]},""position_x"":""92"",""position_y"":""341"",""connectors"":[],""inputEndpoints"":[""dataset1"",""dataset2"",""dataset3""],""outputEndpoints"":[""out""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n""},""context"":[]},{""id"":""XraxM"",""alias"":""Create Case"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""create_case"",""requirements"":"""",""params"":[],""script"":[""def create_case(type, payload):\\r\\r    '''\\r\\r    use to create case\\r\\r    '''\\r\\r    header = {\\r\\r        'Accept': 'application/json, text/plain, */*',\\r\\r        'Content-Type': 'application/json',\\r\\r        'Project': Leap_Project_Id,\\r\\r        'ProjectName': Leap_Project_Name,\\r\\r        'Access-Token': os.environ[\\""Leap_access_token\\""]\\r\\r    }\\r\\r    url = f'''{Leap_URL}/api/aip/inbox/startProcess/{Leap_Project_Name}/{type}/Manual?ocrIdList='''\\r\\r    json_data = payload\\r\\r    response = requests.post(url=url, headers=header, json=json_data, verify=False)\\r\\r    logger.info(\\""Create Case \\"" + response.text)\\r\\r    if response.status_code == 201:\\r\\r        status_message = response.text\\r\\r        return status_message\\r\\r    else:\\r\\r        return response.text\\r\\r\\r\\r\\r\\rdef getCaseStatus(case_id: str):\\r\\r    '''\\r\\r    use to get status of the case based on case ID provided, case ID is of the format RA:00000165.\\r\\r    '''\\r\\r    header = {\\r\\r        'Accept': 'application/json, text/plain, */*',\\r\\r        'Content-Type': 'application/json',\\r\\r        'Project': Leap_Project_Id,\\r\\r        'ProjectName': Leap_Project_Name,\\r\\r        'Access-Token':  os.environ[\\""Leap_access_token\\""]\\r\\r    }\\r\\r    url = f'''{Leap_URL}/api/aip/datasets/searchData?page=0&size=1&sortEvent=BID&sortOrder=-1&datasetName=JCIJC_DM87192&projectName={Leap_Project_Name}&searchParams=%7B'and':%5B%7B'or':%7B'property':'business_key_','equality':'=','value':\\""{case_id}\\""%7D%7D%5D%7D'''\\r\\r    response = requests.get(url=url, headers=header, verify=False)\\r\\r    print(response)\\r\\r    if response.status_code == 200:\\r\\r        status_message = response.text\\r\\r        response = llm_invoke(status_message, \\""summarize the data {data}\\"")\\r\\r        return response\\r\\r""]},""position_x"":""439"",""position_y"":""38"",""connectors"":[],""inputEndpoints"":[""dataset1"",""dataset2"",""dataset3""],""outputEndpoints"":[""out""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n""},""context"":[]},{""id"":""QzVBJ"",""alias"":""Ticket Recommendation"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""tempFunc"",""requirements"":"""",""params"":[],""script"":[""from langchain.agents import AgentExecutor, tool, create_structured_chat_agent\\r\\r\\r\\r\\r\\r@tool(\\""Create a ticket\\"", return_direct=True)\\r\\r\\r\\rdef create_ticket(shortdescription):\\r\\r\\r\\r    \\""\\""\\""\\r\\r\\r\\r        Use this tool to create a ticket in Serice now\\r\\r\\r\\r        Parameters:\\r\\r\\r\\r            shortdescription (str): Short description of the ticket\\r\\r\\r\\r        Returns:\\r\\r\\r\\r           Navigates to  recommendations tab\\r\\r\\r\\r        \\""\\""\\""\\r\\r\\r\\r    url = f\\""{os.environ['SNOW_url']}api/now/table/incident\\""\\r\\r\\r\\r    from requests.auth import HTTPBasicAuth\\r\\r\\r\\r    payload = json.dumps({\\r\\r\\r\\r        \\""short_description\\"": shortdescription,\\r\\r\\r\\r        \\""priority\\"": \\""5\\"",\\r\\r\\r\\r        \\""state\\"": \\""1\\"",\\r\\r\\r\\r        \\""cmdb_ci\\"": \\""60e2f0c58764ca50a79462ce8bbb35e9\\""\\r\\r\\r\\r    })\\r\\r\\r\\r    headers = {\\r\\r\\r\\r        'Content-Type': 'application/json',\\r\\r\\r\\r        'Authorization': HTTPBasicAuth(os.environ['SNOW_username'], os.environ['SNOW_password'])\\r\\r\\r\\r        }\\r\\r\\r\\r    try:\\r\\r\\r\\r        response = requests.request(\\""POST\\"", url, headers=headers, data=payload, verify=False)\\r\\r\\r\\r        print(f\\""Create Ticket response is {response.status_code} and {response}\\"")\\r\\r\\r\\r        if response.status_code==201:\\r\\r\\r\\r            final_answer = {\\r\\r\\r\\r                \\""chat_system_response\\"": \\""Incident created with number: \\""+json.loads(response.text)['result']['number']\\r\\r\\r\\r            }\\r\\r\\r\\r            return json.dumps(final_answer)\\r\\r\\r\\r        else:\\r\\r\\r\\r            final_answer = {\\r\\r\\r\\r                \\""chat_system_response\\"": \\""Error in creating ticket\\""\\r\\r\\r\\r            }\\r\\r\\r\\r            return json.dumps(final_answer)\\r\\r        \\r\\r    except Exception as e:\\r\\r        print(f'Got Exception in Create Ticket as {e}')\\r\\r\\r\\r        \\r\\r\\r\\r@tool(\\""Get ticket recommendations\\"", return_direct=True)\\r\\r\\r\\rdef fetch_tickets_recommendation(number: str) -> str:\\r\\r\\r\\r    \\""\\""\\""\\r\\r\\r\\r    Use this tool to show recommendations for a ticket. Recommendations include recommended SOP, recommended assignment, recommended assignee,\\r\\r\\r\\r    etc\\r\\r\\r\\r    Parameters:\\r\\r\\r\\r        number (str): Ticket number\\r\\r\\r\\r    Returns:\\r\\r\\r\\r       Navigates to  recommendations tab\\r\\r\\r\\r    \\""\\""\\""\\r\\r\\r\\r    navigateurl = \\""landing/aip/tickets/create-ticket/{0}?tab=Recommendations\\"".format(number)\\r\\r\\r\\r    final_answer = {\\r\\r\\r\\r        \\""chat_system_response\\"": \\""Showing recommendations for the ticket\\"",\\r\\r\\r\\r        \\""navigateUrl\\"": navigateurl\\r\\r\\r\\r    }\\r\\r\\r\\r    return json.dumps(final_answer)\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""Fetch Tickets\\"", return_direct=True)\\r\\r\\r\\rdef fetch_tickets(query: str) -> str:\\r\\r\\r\\r    \\""\\""\\""\\r\\r\\r\\r    Use this tool  to answer all the queries related to ticket or details.\\r\\r\\r\\r    If user asks to process tickets then fetch top 5 tickets from database and send the data , do not summarize\\r\\r\\r\\r    If user asks for troubleshoot tickets then fetch top 5 tickets with column tags=troubleshoot from database and send the data , do not summarize\\r\\r\\r\\r    If user asks to fetch details of the ticket then get the details from database based on number of tickets\\r\\r\\r\\r    Parameters:\\r\\r\\r\\r        query (str): A question in natural language form which is sent by user.\\r\\r\\r\\r    Returns:\\r\\r\\r\\r        A  dictionary containing the relevant details fetched from the database based on the SQL query.\\r\\r\\r\\r    \\""\\""\\""\\r\\r\\r\\r    host = os.environ['app_DB_HOST']\\r\\r\\r\\r    user = \\""leapadm\\""\\r\\r\\r\\r    password = os.environ['app_DB_PASSWORD']\\r\\r\\r\\r    database = os.environ['Data_DB']\\r\\r\\r\\r    port = os.environ['Data_DB_port']\\r\\r\\r\\r    encoded_password = urllib.parse.quote(password)\\r\\r\\r\\r    connection_string = f\\""mysql://{user}:{encoded_password}@{host}:{port}/{database}\\""\\r\\r\\r\\r    table_name = os.environ[\\""Leap_Project_Name\\""]+\\""_tickets\\""\\r\\r\\r\\r    db = SQLDatabase.from_uri(connection_string, include_tables=[table_name])\\r\\r\\r\\r    template = '''\\r\\r\\r\\r            Given an input question, first create a syntactically correct query to run, then look at the results of the query \\r\\r\\r\\r            and return the answer and it should be {top_k} \\r\\r\\r\\r            In SQL query try to include \\r\\r\\r\\r            shortdescription, priority, assignedto, number, createdDate, createdby , configurationItem and state  columns.\\r\\r\\r\\r            for ticket use type in (incident , incidents) and for alerts use type=alerts. Always get top results ordered by createddate in descending order.\\r\\r\\r\\r            If user asks to process tickets then fetch top 5 tickets from database and send the data , do not summarize\\r\\r\\r\\r            If user asks for troubleshoot tickets then fetch top 5 tickets where column tags has value troubleshoot from database and send the data , do not summarize\\r\\r\\r\\r            If user asks for ticket details then get the details of ticket based on number from database and the sql query should include \\r\\r\\r\\r            shortdescription, priority, assignedto, number, createdDate, createdby , configurationItem and state  columns.\\r\\r\\r\\r            Do not use this tool for any knowledge base or knowledge search related questions.\\r\\r\\r\\r            If user asks for recurring issues then fetch top 5 most occuring short descriptions\\r\\r\\r\\r            Only use the following tables: {table_info}.\\r\\r\\r\\r            Question: {input}\\r\\r\\r\\r            and just return the SQL Query to run as the final response without mentioning SQL: in the final response.\\r\\r\\r\\r            '''\\r\\r\\r\\r    prompt = PromptTemplate.from_template(template)\\r\\r\\r\\r    chain = create_sql_query_chain(llm, db, prompt=prompt)\\r\\r\\r\\r    response = chain.invoke({\\""question\\"": query})\\r\\r\\r\\r    print(response)\\r\\r\\r\\r    mydb = mysql.connector.connect(\\r\\r\\r\\r    host = os.environ['app_DB_HOST'],\\r\\r\\r\\r    user = \\""leapadm\\"",\\r\\r\\r\\r    password = os.environ['app_DB_PASSWORD'],\\r\\r\\r\\r    database = os.environ['Data_DB'],\\r\\r\\r\\r    port = os.environ['Data_DB_port']\\r\\r\\r\\r    )\\r\\r\\r\\r    mycursor = mydb.cursor(dictionary=True)\\r\\r\\r\\r    mycursor.execute(response)\\r\\r\\r\\r    data = mycursor.fetchall()\\r\\r\\r\\r    try:\\r\\r\\r\\r        if len(data) == 0:\\r\\r\\r\\r            answer = \\""No Record has been found.\\""\\r\\r            final_answer = {\\r\\r            \\""chat_system_response\\"": answer\\r\\r            }\\r\\r            print(final_answer)\\r\\r            return json.dumps(final_answer)\\r\\r\\r\\r        if len(data) == 1 and data[0]['number'] is not None:\\r\\r\\r\\r            navigateurl = \\""landing/aip/tickets/create-ticket/{0}?tab=Summary\\"".format(data[0]['number'])\\r\\r\\r\\r        elif len(data) > 0:\\r\\r\\r\\r            navigateurl = \\""landing/aip/tickets/incident\\""\\r\\r\\r\\r\\r\\r        user_prompt = '''\\r\\r\\r\\r                For the given data  - \\r\\r\\r\\r                {data}\\r\\r\\r\\r                Generated summary for each of the object in  the following format:\\r\\r\\r\\r                Number: INC424244\\r\\r\\r\\r                Short Descrption: short description\\r\\r\\r\\r                The ticket was created by admin, on Thu, 01 Oct 2020 17:11:11 GMT with high priority and it's been assigned to DAS group and the ticket is currently in open state.\\r\\r\\r\\r\\r\\r\\r\\r                DO not fail for misiing information , summarize whatever you can\\r\\r\\r\\r                '''\\r\\r\\r\\r        answer = llm_invoke(data, user_prompt=user_prompt)\\r\\r\\r\\r        final_answer = {\\r\\r\\r\\r            \\""chat_system_response\\"": answer,\\r\\r\\r\\r            \\""navigateUrl\\"": navigateurl\\r\\r\\r\\r        }\\r\\r\\r\\r        print(final_answer)\\r\\r\\r\\r        return json.dumps(final_answer)\\r\\r\\r\\r    except:\\r\\r\\r\\r        final_answer = {\\r\\r\\r\\r            \\""chat_system_response\\"": data}\\r\\r\\r\\r        return json.dumps(final_answer)\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""Fetch Alerts\\"", return_direct=True)\\r\\r\\r\\rdef fetch_alerts(query: str) -> str:\\r\\r\\r\\r    \\""\\""\\""\\r\\r\\r\\r    Use this tool  to answer all the queries related to alerts or alert details.\\r\\r\\r\\r    If user asks to fetch details of the ticket then get the details from database based on alert number\\r\\r\\r\\r    Parameters:\\r\\r\\r\\r        query (str): A question in natural language form which is sent by user.\\r\\r\\r\\r    Returns:\\r\\r\\r\\r        A  dictionary containing the relevant details fetched from the database based on the SQL query.\\r\\r\\r\\r    \\""\\""\\""\\r\\r\\r\\r    host = os.environ['app_DB_HOST']\\r\\r\\r\\r    user = \\""leapadm\\""\\r\\r\\r\\r    password = os.environ['app_DB_PASSWORD']\\r\\r\\r\\r    database = os.environ['Data_DB']\\r\\r\\r\\r    port = os.environ['Data_DB_port']\\r\\r\\r\\r    encoded_password = urllib.parse.quote(password)\\r\\r\\r\\r    # connection_string=os.environ.get('app_sql_connection')\\r\\r\\r\\r    connection_string = f\\""mysql://{user}:{encoded_password}@{host}:{port}/{database}\\""\\r\\r\\r\\r    table_name = os.environ[\\""Leap_Project_Name\\""]+\\""_tickets\\""\\r\\r\\r\\r    db = SQLDatabase.from_uri(connection_string, include_tables=[table_name])\\r\\r\\r\\r    template = '''\\r\\r\\r\\r            Given an input question, first create a syntactically correct query to run, then look at the results of the query \\r\\r\\r\\r            and return the answer and it should be {top_k} and the sql query should include \\r\\r\\r\\r            shortdescription, priority, assignedto, number, createdDate, createdby , configurationItem and state  columns for all the query unless and untill the query wants to have some specific columns then have those only.\\r\\r\\r\\r            for alerts use type=alerts. Always get top results ordered by createddate in descending order.\\r\\r\\r\\r            If user asks for alert details then get the details of alert based on number from database\\r\\r\\r\\r            If user asks for recurring issues then fetch top 5 most occuring short descriptions\\r\\r\\r\\r            Only use the following tables: {table_info}.\\r\\r\\r\\r            Question: {input}\\r\\r\\r\\r            amd just return the SQL Query to run as the final response without mentioning SQL: in the final response.\\r\\r\\r\\r            '''\\r\\r\\r\\r    prompt = PromptTemplate.from_template(template)\\r\\r\\r\\r    chain = create_sql_query_chain(llm, db, prompt=prompt)\\r\\r\\r\\r    response = chain.invoke({\\""question\\"": query})\\r\\r\\r\\r    mydb = mysql.connector.connect(\\r\\r\\r\\r        host=os.environ['app_DB_HOST'],\\r\\r\\r\\r    user = \\""leapadm\\"",\\r\\r\\r\\r    password = os.environ['app_DB_PASSWORD'],\\r\\r\\r\\r    database = os.environ['Data_DB'],\\r\\r\\r\\r    port = os.environ['Data_DB_port']\\r\\r\\r\\r    )\\r\\r\\r\\r    mycursor = mydb.cursor(dictionary=True)\\r\\r\\r\\r    mycursor.execute(response)\\r\\r\\r\\r    data = mycursor.fetchall()\\r\\r\\r\\r    if len(data) == 1:\\r\\r\\r\\r        navigateurl = \\""landing/aip/tickets/create-ticket/{0}?tab=Summary\\"".format(data[0]['number'])\\r\\r\\r\\r    else:\\r\\r\\r\\r        navigateurl = \\""landing/aip/tickets/alerts\\""\\r\\r\\r\\r    user_prompt = '''\\r\\r\\r\\r            For the given data  - \\r\\r\\r\\r            {data}\\r\\r\\r\\r            Generated summary for each of the object in  the following format:\\r\\r\\r\\r            Number: INC424244\\r\\r\\r\\r            Details:\\r\\r\\r\\r            This ticket has short description as Process_Invoice_Id:12345, the ticket was created by admin, on Thu, 01 Oct 2020 17:11:11 GMT with high priority and it's been assigned to DAS group and the ticket is currently in open state.\\r\\r\\r\\r            '''\\r\\r\\r\\r    answer = llm_invoke(data, user_prompt=user_prompt)\\r\\r\\r\\r    final_answer = {\\r\\r\\r\\r        \\""chat_system_response\\"": answer,\\r\\r\\r\\r        \\""navigateUrl\\"": navigateurl\\r\\r\\r\\r    }\\r\\r\\r\\r    return json.dumps(final_answer)\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""Related CIs\\"", return_direct=True)\\r\\r\\r\\rdef related_ci(number: str) -> str:\\r\\r\\r\\r    \\""\\""\\""\\r\\r\\r\\r    Use this tool  to fetch configurationItem and cmdb_ci_sys_id from the database for a given ticket\\r\\r\\r\\r    Parameters:\\r\\r\\r\\r        number (str): ticket number\\r\\r\\r\\r    Returns:\\r\\r\\r\\r        A  dictionary containing the relevant details fetched from the database based on the SQL query.\\r\\r\\r\\r    \\""\\""\\""\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r    table_name = os.environ[\\""Leap_Project_Name\\""]+\\""_tickets\\""\\r\\r\\r\\r    mydb = mysql.connector.connect(\\r\\r\\r\\r    host=os.environ['app_DB_HOST'],\\r\\r\\r\\r    user = \\""leapadm\\"",\\r\\r\\r\\r    password = os.environ['app_DB_PASSWORD'],\\r\\r\\r\\r    database = os.environ['Data_DB'],\\r\\r\\r\\r    port = os.environ['Data_DB_port']\\r\\r\\r\\r    )\\r\\r\\r\\r    mycursor = mydb.cursor(dictionary=True)\\r\\r\\r\\r    mycursor.execute(f\\""Select configurationItem ,cmdb_ci_sys_id from {table_name} where number = '{number}' \\"")\\r\\r\\r\\r    data = mycursor.fetchall()\\r\\r\\r\\r    if data[0]['cmdb_ci_sys_id'] == None:\\r\\r\\r\\r        final_answer = {\\r\\r\\r\\r            \\""chat_system_response\\"": \\""Could not find any related CIs\\""\\r\\r\\r\\r        }\\r\\r\\r\\r    elif len(data) > 0:\\r\\r\\r\\r        navigateURL = 'landing/iamp-graph/network/ConfigItem?cmdb_ci_sys_id={0}'.format(data[0]['cmdb_ci_sys_id'])\\r\\r\\r\\r        final_answer = {\\r\\r\\r\\r            \\""chat_system_response\\"": \\""Showing graph for \\"" + data[0]['configurationItem'],\\r\\r\\r\\r            \\""navigateUrl\\"": navigateURL\\r\\r\\r\\r        }\\r\\r\\r\\r    else:\\r\\r\\r\\r        final_answer = {\\r\\r\\r\\r            \\""chat_system_response\\"": \\""Could not find any related CIs\\""\\r\\r\\r\\r        }\\r\\r\\r\\r    return json.dumps(final_answer)\\r\\r\\r\\r\\r\\r@tool(\\""Ticket Resolver\\"", return_direct=True)\\r\\rdef resolve_ticket(number, shortdescription):\\r\\r    '''\\r\\r    use this tool when user asks to resolve a ticket, do not use this tool to troubleshoot or fetch details of ticket\\r\\r    parameter:\\r\\r        number(str) : Ticket/Alert number to resolve\\r\\r        shortdescription(str) : short description of the ticket to resolve ; if short description is not found then fetch the details of the ticket using number\\r\\r        return: returns response for the user query\\r\\r    '''\\r\\r    if shortdescription == None or shortdescription == '':\\r\\r        shortdescription = fetch_tickets(\\""Get short description of ticket \\"" + number)\\r\\r        print(shortdescription)\\r\\r\\r\\r    response = icap_classify_ticket(number)\\r\\r    print(response)\\r\\r    if json.loads(response)['ErrorData'] == \\""No tickets found to classify.\\"":\\r\\r        icap_extract_tickets(shortdescription)\\r\\r    response = icap_classify_ticket(number)\\r\\r    print(response)\\r\\r    answer = {\\r\\r        \\""chat_system_response\\"": \\""Ticket Classified Successfully\\"",\\r\\r        'chat_suggestions': [json.loads(response)['SuccessData'].title() + \\"". Proceed with verification.\\"",\\r\\r                             \\""No, do not verify ticket\\""]\\r\\r    }\\r\\r\\r\\r    return json.dumps(answer)\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""Verify Ticket\\"", return_direct=True)\\r\\r\\r\\rdef verify_ticket(number: str, workflowName: str, verified: bool):\\r\\r\\r\\r    '''\\r\\r\\r\\r        use this tool when user asks to proceed with ticket verification\\r\\r\\r\\r        parameter:\\r\\r\\r\\r            number(str) : Ticket/Alert number to resolve\\r\\r\\r\\r            workflowname(str) : workflowname assigned to ticket\\r\\r\\r\\r            verified(bool): ticket is verified or not  If user proceeds with resolution then True else False\\r\\r\\r\\r        return: returns response for the user query\\r\\r\\r\\r        '''\\r\\r\\r\\r    if verified == True:\\r\\r\\r\\r        try:\\r\\r\\r\\r            import random\\r\\r\\r\\r            import string\\r\\r\\r\\r            random_digits = ''.join(random.choices(string.digits, k=4))\\r\\r\\r\\r            # Construct the unique ID with the desired format\\r\\r\\r\\r            unique_id = f\\""WFE{random_digits}\\""\\r\\r\\r\\r            payload = {\\""eventTypeName\\"": \\""Resolve Ticket\\"",\\r\\r\\r\\r                       \\""context\\"": {\\""requestId\\"": unique_id,\\r\\r\\r\\r                                   \\""ticketId\\"": number}}\\r\\r\\r\\r            workflowInstanceid, workflowid = trigger_emf_workflow(payload)\\r\\r\\r\\r            if workflowInstanceid is not None and workflowInstanceid != '':\\r\\r\\r\\r                answer = {\\r\\r\\r\\r                    \\""chat_system_response\\"": f\\""Workflow triggered successfully. \\"",\\r\\r\\r\\r                    \\""navigateUrl\\"": f\\""landing/iamp-eda/trigger-workflow?workflowId={workflowid}&instanceid={workflowInstanceid}\\"",\\r\\r\\r\\r                    'chat_suggestions': [\\r\\r\\r\\r                        f\\""Get Workflow Status. WorkflowId:{workflowid}, InstanceId={workflowInstanceid} \\""]\\r\\r\\r\\r                }\\r\\r\\r\\r                return json.dumps(answer)\\r\\r\\r\\r            else:\\r\\r\\r\\r                answer = {\\r\\r\\r\\r                    \\""chat_system_response\\"": \\""Unable to trigger workflow!!\\""\\r\\r\\r\\r                }\\r\\r\\r\\r            return json.dumps(answer)\\r\\r\\r\\r        except Exception as e:\\r\\r\\r\\r            logger.error(f\\""Got Exception in Code Method with msg: {e}\\"")\\r\\r\\r\\r    else:\\r\\r\\r\\r        answer = {\\r\\r\\r\\r            \\""chat_system_response\\"": \\""Ticket resolution not triggered\\""\\r\\r\\r\\r        }\\r\\r\\r\\r        return json.dumps(answer)\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""Enrich Ticket\\"", return_direct=True)\\r\\r\\r\\rdef enrich_ticket(number: str):\\r\\r\\r\\r    '''\\r\\r\\r\\r        use this tool when user asks to enrich the ticket\\r\\r\\r\\r        parameter:\\r\\r\\r\\r            number(str) : Ticket/Alert number to enrich\\r\\r\\r\\r        return: returns response for the user query\\r\\r\\r\\r        '''\\r\\r\\r\\r    try:\\r\\r\\r\\r        import random\\r\\r\\r\\r        import string\\r\\r\\r\\r        random_digits = ''.join(random.choices(string.digits, k=4))\\r\\r\\r\\r        # Construct the unique ID with the desired format\\r\\r\\r\\r        unique_id = f\\""WFE{random_digits}\\""\\r\\r\\r\\r        payload = {\\""eventTypeName\\"": \\""Fetch Ticket Details\\"",\\r\\r\\r\\r                   \\""context\\"": {\\""ExecutionId\\"": unique_id,\\r\\r\\r\\r                               \\""ticketId\\"": number}}\\r\\r\\r\\r        workflowInstanceid, workflowid = trigger_emf_workflow(payload)\\r\\r\\r\\r        if workflowInstanceid is not None and workflowInstanceid != '':\\r\\r\\r\\r            answer = {\\r\\r\\r\\r                \\""chat_system_response\\"": f\\""Workflow triggered successfully. \\"",\\r\\r\\r\\r                \\""navigateUrl\\"": f\\""landing/iamp-eda/trigger-workflow?workflowId={workflowid}&instanceid={workflowInstanceid}\\"",\\r\\r\\r\\r                'chat_suggestions': [\\r\\r\\r\\r                    f\\""Get Workflow Status. WorkflowId:{workflowid}, InstanceId={workflowInstanceid} \\""]\\r\\r\\r\\r            }\\r\\r\\r\\r            return json.dumps(answer)\\r\\r\\r\\r        else:\\r\\r\\r\\r            answer = {\\r\\r\\r\\r                \\""chat_system_response\\"": \\""Unable to trigger workflow!!\\""\\r\\r\\r\\r            }\\r\\r\\r\\r        return json.dumps(answer)\\r\\r\\r\\r    except Exception as e:\\r\\r\\r\\r        logger.error(f\\""Got Exception in Code Method with msg: {e}\\"")\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""Self help\\"", return_direct=True)\\r\\r\\r\\rdef self_help(query: str) -> str:\\r\\r\\r\\r    '''\\r\\r\\r\\r    Use this tool to give menu options available for self help:\\r\\r\\r\\r    The options are-\\r\\r\\r\\r        1. Role Assignment\\r\\r\\r\\r        2. Password Reset\\r\\r\\r\\r    '''\\r\\r\\r\\r    try:\\r\\r\\r\\r        list = [\\""Role Assignment\\"", \\""Password Reset\\""]\\r\\r\\r\\r        answer = {\\r\\r\\r\\r            \\""chat_system_response\\"": \\""Choose from the options\\"",\\r\\r\\r\\r            'chat_suggestions': list\\r\\r\\r\\r        }\\r\\r\\r\\r        return json.dumps(answer)\\r\\r\\r\\r        # return final\\r\\r\\r\\r    except Exception as e:\\r\\r\\r\\r        logger.debug(f\\""Exception in self help tool : {e}\\"")\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""main menu\\"", return_direct=True)\\r\\r\\r\\rdef main_menu(query: str) -> str:\\r\\r\\r\\r    '''\\r\\r\\r\\r    Use this tool to give main menu options or if user want to know what all can be done with this chatbot\\r\\r\\r\\r    The options are-\\r\\r\\r\\r        1. Process Tickets\\r\\r\\r\\r        2. Troubleshoot Tickets\\r\\r\\r\\r        3. Self help\\r\\r\\r\\r        4. Knowledge search\\r\\r\\r\\r    '''\\r\\r\\r\\r    try:\\r\\r\\r\\r        list = [\\""Process Tickets\\"", \\""Troubleshoot Tickets\\"", \\""Self help\\"", \\""Knowledge search\\""]\\r\\r\\r\\r        answer = {\\r\\r\\r\\r            \\""chat_system_response\\"": \\""Choose from the options\\"",\\r\\r\\r\\r            'chat_suggestions': list\\r\\r\\r\\r        }\\r\\r\\r\\r        return json.dumps(answer)\\r\\r\\r\\r        # return final\\r\\r\\r\\r    except Exception as e:\\r\\r\\r\\r        logger.debug(f\\""Exception in self help tool : {e}\\"")\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""Password Reset\\"", return_direct=True)\\r\\r\\r\\rdef password_reset(system_id='', old_password='', new_password='') -> str:\\r\\r\\r\\r    '''\\r\\r\\r\\r    Use this tool to reset password for a system. password is set for a system; it is not mandatory\\r\\r\\r\\r    parameter:\\r\\r\\r\\r        system_id(str) : System Id for which the password rest has to be done.\\r\\r\\r\\r        old_password(str) : Old password\\r\\r\\r\\r        new_password(str) : New password\\r\\r\\r\\r    return: returns response for the user query\\r\\r\\r\\r    '''\\r\\r\\r\\r    try:\\r\\r\\r\\r        if system_id is None or system_id == '' or old_password is None or old_password == '' or new_password is None or new_password == '':\\r\\r\\r\\r            answer = {\\r\\r\\r\\r                'chat_system_response': \\""LEOPSWRD43672\\"",\\r\\r\\r\\r                'type': 'Form',\\r\\r\\r\\r                'chat_formName': \\""LEOPSWRD43672\\"",\\r\\r\\r\\r                'form_fields': {\\r\\r\\r\\r                    'system_id': system_id,\\r\\r\\r\\r                    'old_password': old_password,\\r\\r\\r\\r                    'new_password': new_password,\\r\\r\\r\\r                    'requested_by': \\""\\""\\r\\r\\r\\r                },\\r\\r\\r\\r                'chat_suggestions': None\\r\\r\\r\\r            }\\r\\r\\r\\r            return json.dumps(answer)\\r\\r\\r\\r        else:\\r\\r\\r\\r            response = create_case('Password_reset', payload={\\r\\r\\r\\r                'system_id': system_id,\\r\\r\\r\\r                'old_password': old_password,\\r\\r\\r\\r                'new_password': new_password,\\r\\r\\r\\r                'requested_by': \\""\\""\\r\\r\\r\\r            })\\r\\r\\r\\r            answer = {\\r\\r\\r\\r                'chat_system_response': \\""Case Created successfully!\\""\\r\\r\\r\\r            }\\r\\r\\r\\r            return json.dumps(answer)\\r\\r\\r\\r    except Exception as e:\\r\\r\\r\\r        logger.debug(f\\""Exception in  tool : {e}\\"")\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""Role Assignment\\"", return_direct=True)\\r\\r\\r\\rdef role_assignment(system_id='', role_id='') -> str:\\r\\r\\r\\r    '''\\r\\r\\r\\r    Use this tool for role assignment queries. if user has not provided system_id or role_id then take empty as default\\r\\r\\r\\r    parameter:\\r\\r\\r\\r        system_id(str) : System Id\\r\\r\\r\\r        role_id:(str) : Role id\\r\\r\\r\\r    return: returns response for the user query\\r\\r\\r\\r    '''\\r\\r\\r\\r    if system_id is None or system_id == '' or role_id is None or role_id == '':\\r\\r\\r\\r        answer = {\\r\\r\\r\\r            'chat_system_response': \\""JCITSTXW52953\\"",\\r\\r\\r\\r            'type': 'Form',\\r\\r\\r\\r            'chat_formName': \\""JCITSTXW52953\\"",\\r\\r\\r\\r            'form_fields': {\\r\\r\\r\\r                'system_id': system_id,\\r\\r\\r\\r                'role_id': role_id,\\r\\r\\r\\r                'requested_by': \\""\\""\\r\\r\\r\\r            },\\r\\r\\r\\r            'chat_suggestions': None\\r\\r\\r\\r        }\\r\\r\\r\\r        return json.dumps(answer)\\r\\r\\r\\r    else:\\r\\r\\r\\r        print(\\""In else of Role assignment\\"")\\r\\r\\r\\r        response = create_case('Role_assignment', payload={\\r\\r\\r\\r            'system_list': system_id,\\r\\r\\r\\r            'role_list': role_id,\\r\\r\\r\\r            'requested_by': \\""admin@infosys.com\\""\\r\\r\\r\\r        })\\r\\r\\r\\r        print(response)\\r\\r\\r\\r        answer = {\\r\\r\\r\\r            'chat_system_response': response\\r\\r\\r\\r        }\\r\\r\\r\\r        return json.dumps(answer)\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""Navigator\\"", return_direct=True)\\r\\r\\r\\rdef url_navigator(query: str) -> str:\\r\\r\\r\\r    '''\\r\\r\\r\\r    use this tool, when user asks to navigate or when user query is related to navigate\\r\\r\\r\\r    parameters: query: user query asking to navigate\\r\\r\\r\\r    returns: Returns navigate urls\\r\\r\\r\\r    '''\\r\\r\\r\\r    try:\\r\\r\\r\\r        user_prompt = '''\\r\\r\\r\\r        Understand the query and match with the following list of options and return most relevant option from the list\\r\\r\\r\\r        query list = [navigate to tickets, navigate to tickets_analytics, navigate to bcc, navigate to cis, navigate to emf]\\r\\r\\r\\r        {data}\\r\\r\\r\\r        '''\\r\\r\\r\\r        prompt = ChatPromptTemplate.from_template(user_prompt)\\r\\r\\r\\r        chain = prompt | llm\\r\\r\\r\\r        response = chain.invoke({\\""data\\"": query})\\r\\r\\r\\r        if (response.content).lower() == \\""navigate to tickets\\"":\\r\\r\\r\\r            final = \\""landing/aip/tickets/alerts\\""\\r\\r\\r\\r        elif (response.content).lower() == \\""navigate to bcc\\"":\\r\\r\\r\\r            final = \\""landing/cc/OCC/52\\""\\r\\r\\r\\r        elif (response.content).lower() == \\""navigate to tickets_analytics\\"":\\r\\r\\r\\r            final = \\""landing/dynamicDashboard/grid/OCC/2\\""\\r\\r\\r\\r        elif (response.content).lower() == \\""navigate to cis\\"":\\r\\r\\r\\r            final = \\""landing/iamp-cis\\""\\r\\r\\r\\r        elif (response.content).lower() == \\""navigate to emf\\"":\\r\\r\\r\\r            final = \\""landing/iamp-eda\\""\\r\\r\\r\\r        else:\\r\\r\\r\\r            final = \\""Unable to locate navigate url\\""\\r\\r\\r\\r            query = final\\r\\r\\r\\r        answer = {\\r\\r\\r\\r            \\""chat_system_response\\"": query,\\r\\r\\r\\r            # \\""chat_chain_of_thoughts\\"":\\"" \\"",\\r\\r\\r\\r            \\""navigateUrl\\"": final\\r\\r\\r\\r        }\\r\\r\\r\\r        return json.dumps(answer)\\r\\r\\r\\r        # return final\\r\\r\\r\\r    except Exception as e:\\r\\r\\r\\r        logger.debug(f\\""Exception in URL navigator tool : {e}\\"")\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""Workflow Status\\"", return_direct=True)\\r\\r\\r\\rdef get_workflow_status(workflowId, instanceid):\\r\\r\\r\\r    '''\\r\\r\\r\\r    use this tool to get the status of the workflow\\r\\r\\r\\r    parameter: workflowId(str): workflowid of the workflow\\r\\r\\r\\r    parameter: workflowId(str): instanceid of the workflow\\r\\r\\r\\r    returns: returns the status of the workflow\\r\\r\\r\\r    '''\\r\\r\\r\\r    try:\\r\\r\\r\\r\\r\\r\\r\\r        answer = {\\r\\r\\r\\r            \\""chat_system_response\\"": \\""Refreshed Status\\"",\\r\\r\\r\\r            \\""navigateUrl\\"": f\\""landing/iamp-eda/trigger-workflow?workflowId={workflowId}&instanceid={instanceid}\\""\\r\\r\\r\\r        }\\r\\r\\r\\r        return json.dumps(answer)\\r\\r\\r\\r    except Exception as e:\\r\\r\\r\\r        logger.error(f\\""Got Exception in Workflow Status Method with msg: {e}\\"")\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""Case Status\\"", return_direct=True)\\r\\r\\r\\rdef get_case_status(caseId):\\r\\r\\r\\r    '''\\r\\r\\r\\r    use this tool to get the status of the case\\r\\r\\r\\r    parameter: caseId(str): case id\\r\\r\\r\\r    returns: returns the status of the case\\r\\r\\r\\r    '''\\r\\r\\r\\r    try:\\r\\r\\r\\r        response = getCaseStatus(caseId)\\r\\r\\r\\r        answer = {\\r\\r\\r\\r            \\""chat_system_response\\"": response\\r\\r\\r\\r        }\\r\\r\\r\\r        return json.dumps(answer)\\r\\r\\r\\r    except Exception as e:\\r\\r\\r\\r        logger.error(f\\""Got Exception in Workflow Status Method with msg: {e}\\"")\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""Related Tickets\\"", return_direct=True)\\r\\r\\r\\rdef related_tickets(shortdescription, number):\\r\\r\\r\\r    '''\\r\\r\\r\\r    use this tool to get related tickets of any ticket based on its short description\\r\\r\\r\\r    parameter:\\r\\r\\r\\r        shortdescription(str) : short description of the ticket\\r\\r\\r\\r        number(str): ticket number for which related tickets are fetched\\r\\r\\r\\r    return: returns response for the user query\\r\\r\\r\\r    '''\\r\\r\\r\\r    # try:\\r\\r\\r\\r    headers = {\\r\\r\\r\\r        'Content-Type': 'application/json', \\""Project\\"": \\""2\\""\\r\\r\\r\\r    }\\r\\r\\r\\r    json_data = {\\""index_name\\"":\\""leapdemo-leo1311-tickets\\"",\\""query\\"":shortdescription}\\r\\r\\r\\r    url = f'''{os.environ['LEAP_URL']}/api/aip/adapters/TicketsSearch-Adapter-Instance/semanticsearch_infer/{os.environ['Leap_Project_Name']}?isInstance=true'''\\r\\r\\r\\r    response = requests.post(url, headers=headers, json=json_data, verify=False)\\r\\r\\r\\r    mainAnswer = \\""Related Tickets\\"" + os.linesep\\r\\r\\r\\r    if response.status_code == 200:\\r\\r\\r\\r        answer = json.loads(response.text)[0].get('Answer')\\r\\r\\r\\r        navigateurl = \\""landing/aip/tickets/create-ticket/{0}?tab=RelatedTickets\\"".format(number)\\r\\r\\r\\r\\r\\r\\r\\r        answer = {\\r\\r\\r\\r            \\""chat_system_response\\"": answer,\\r\\r\\r\\r            \\""navigateUrl\\"": navigateurl\\r\\r\\r\\r        }\\r\\r\\r\\r        return json.dumps(answer)\\r\\r\\r\\r    else:\\r\\r\\r\\r        mainAnswer = f\\""There is an issue in Adapter, response status: {response.status_code} , {response.text}\\""\\r\\r\\r\\r\\r\\r\\r\\r    return mainAnswer\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""Knowledge Search\\"", return_direct=True)\\r\\r\\r\\rdef knowledge_search(query='', knowledge_base=''):\\r\\r\\r\\r    '''\\r\\r\\r\\r    use this tool for knowledge search. if user has not provided any knowledge base then ask the user to select knowledge_base.\\r\\r\\r\\r    After user selects the knowledge_base , then show suggested queries\\r\\r\\r\\r    Available Knowledge Base are  SAP, Infosys-SAP-KB, SOP and App Help\\r\\r\\r\\r    Do not assume any knowledge base name and query on your own\\r\\r\\r\\r    If user choose the knowledge base name , then ask user for the query. Don't generate random query\\r\\r\\r\\r    Parameters:\\r\\r\\r\\r        query (str): A question in natural language which is sent by user. If user has not given any query then use ''\\r\\r\\r\\r        knowledge_base(str): knowledge_base name to search on\\r\\r\\r\\r    Returns:\\r\\r\\r\\r        returns response for the user query.\\r\\r\\r\\r    '''\\r\\r\\r\\r    final_response = dict()\\r\\r\\r\\r    if (knowledge_base == 'Knowledge Search' or  knowledge_base == '') and query =='':\\r\\r\\r\\r        print(\\""Inside IF WIth Knowledge Base and Query and empty\\"")\\r\\r\\r\\r        index_list = [\\""SAP\\"", \\""Infosys-SAP-KB\\"", \\""SOP\\""]\\r\\r\\r\\r        final_response = {\\r\\r\\r\\r            \\""chat_system_response\\"": \\""Choose knowledge base\\"",\\r\\r\\r\\r            'chat_suggestions': index_list\\r\\r\\r\\r        }\\r\\r\\r\\r    elif knowledge_base != '' and query == '':\\r\\r        print('without knowledge_base with query')\\r\\r\\r\\r        suggested_queries = []\\r\\r\\r\\r        answer = get_adapter_response(url=\\""https://leap2:7000/api/aip/mltopics/list/activeMltopicsByOrg/leo1311\\"",\\r\\r\\r\\r                                      type=\\""get\\"")\\r\\r\\r\\r        for i in answer:\\r\\r\\r\\r            if i['topicname'] == knowledge_base:\\r\\r\\r\\r                suggested_queries = json.loads(i['suggested_queries'])\\r\\r\\r\\r                print(f\\""Suggested Queries: {suggested_queries}\\"")\\r\\r\\r\\r                print(f\\""Suggested Query type: {type(suggested_queries)}\\"")\\r\\r\\r\\r        final_response = {\\r\\r\\r\\r            \\""chat_system_response\\"": \\""Suggested queries\\"",\\r\\r\\r\\r            'chat_suggestions': suggested_queries\\r\\r\\r\\r        }\\r\\r\\r\\r\\r\\r\\r\\r    elif knowledge_base != \\""\\"" and query != \\""\\"":\\r\\r        print(\\""Without knowledge_base and without Query\\"")\\r\\r\\r\\r        answer = get_adapter_response(url=\\""https://leap2:7000/api/aip/mltopics/list/activeMltopicsByOrg/leo1311\\"",\\r\\r\\r\\r                                      type=\\""get\\"")\\r\\r\\r\\r        \\r\\r\\r\\r        # if knowledge_base == \\""SAP\\"":\\r\\r\\r\\r        #     index = \\""AzureOpenAI_SAP\\""\\r\\r\\r\\r        # else:\\r\\r\\r\\r        index = knowledge_base\\r\\r\\r\\r\\r\\r\\r\\r        for i in answer:\\r\\r\\r\\r\\r\\r\\r\\r            if i['topicname'] == knowledge_base:\\r\\r\\r\\r                kb_instance = i['adapterinstance']\\r\\r\\r\\r\\r\\r\\r\\r        instance_url = f'https://leap2:7000/api/aip/adapters/SemanticSearch-Azure-Instance/semanticsearch_infer/leo1311?isInstance=true'\\r\\r\\r\\r\\r\\r\\r\\r        kb_response = get_adapter_response(url=instance_url, type=\\""post\\"", query=query, index=index)\\r\\r\\r\\r\\r\\r\\r\\r        queryforurl = urllib.parse.quote(query)\\r\\r\\r\\r\\r\\r\\r\\r        url = f'landing/aip/datasets?page=1&search={queryforurl}&type=&org=leo1311&roleId=1&searchBy=Content&topics={knowledge_base}'\\r\\r\\r\\r\\r\\r\\r\\r        final_response = {\\r\\r\\r\\r\\r\\r\\r\\r            \\""chat_system_response\\"": kb_response,\\r\\r\\r\\r\\r\\r\\r\\r            \\""navigateUrl\\"": url\\r\\r\\r\\r\\r\\r\\r\\r        }      \\r\\r\\r\\r\\r\\r\\r\\r    print(f\\""Response JSON in Knowledge search: {final_response}\\"")\\r\\r\\r\\r    return json.dumps(final_response)\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r@tool(\\""SOP Search\\"", return_direct=True)\\r\\r\\r\\rdef sop_search(query: str):\\r\\r\\r\\r    '''\\r\\r\\r\\r    use this tool to get SOPs of the given query. Give answer in points.\\r\\r\\r\\r    Look for answers for the questions like how to resolve user query or steps to reolve the user query\\r\\r\\r\\r    Parameters:\\r\\r\\r\\r        query (str): A question in natural language which is sent by user.\\r\\r\\r\\r    Returns:\\r\\r\\r\\r        returns response for the user query.\\r\\r\\r\\r    '''\\r\\r\\r\\r    sop_instance = \\""SemanticSearch-Azure-Instance\\""\\r\\r\\r\\r    index = \\""SOP\\""\\r\\r\\r\\r    instance_url = f\\""{os.environ['LEAP_URL']}/api/aip/adapters/{sop_instance}/semanticsearch_infer/{os.environ['Leap_Project_Name']}?isInstance=true\\""\\r\\r\\r\\r    kb_response = get_adapter_response(url=instance_url, type=\\""post\\"", query=query,\\r\\r\\r\\r                                       index=index)\\r\\r\\r\\r    if \\""I'm sorry\\"" not in kb_response:\\r\\r\\r\\r        main_response = kb_response\\r\\r\\r\\r        url = f\\""landing/aip/aip/datasets?page=1&search={query}&type=&org={os.environ['Leap_Project_Name']}&roleId=1&searchBy=Content&topics=SOP\\""\\r\\r\\r\\r    else:\\r\\r\\r\\r        main_response = \\""No SOP found for the query\\""\\r\\r\\r\\r    final_response = {\\r\\r\\r\\r        \\""chat_system_response\\"": main_response,\\r\\r\\r\\r        \\""navigateUrl\\"": url\\r\\r\\r\\r    }\\r\\r\\r\\r    return json.dumps(final_response)\\r\\r\\r\\r\\r\\rdef tempFunc():\\r\\r\\r\\r    pass\\r\\r\\r\\r""]},""position_x"":""90"",""position_y"":""10"",""connectors"":[],""inputEndpoints"":[""dataset1"",""dataset2"",""dataset3""],""outputEndpoints"":[""out""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n""},""context"":[]},{""id"":""WnFmF"",""alias"":""Invoke LLM"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""llm_invoke"",""requirements"":"""",""params"":[],""script"":[""\\rfrom langchain.chains.sql_database.query import create_sql_query_chain\\rfrom langchain_community.utilities.sql_database import SQLDatabase\\rfrom threading import Thread\\rfrom langchain_openai import AzureChatOpenAI\\rfrom langchain.agents import AgentExecutor, tool, create_structured_chat_agent\\rimport requests\\r\\rrequests.packages.urllib3.disable_warnings()\\rfrom langchain_core.prompts import PromptTemplate\\rimport logging\\rfrom langchain.memory import ConversationBufferMemory\\rimport certifi\\rfrom flask import Flask, jsonify, request\\rfrom flask_cors import CORS\\rimport uuid\\rimport os, time, json\\rfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder\\rfrom datetime import datetime\\rimport urllib.parse\\r           \\r\\rfrom langchain.chat_models import AzureChatOpenAI\\rimport os\\r\\rllm = AzureChatOpenAI(\\r    azure_deployment=os.environ['deploymentName'],\\r    model_name='gpt-35-turbo',\\r    api_key=os.environ['app_OPENAI_API_KEY'],\\r    api_version=os.environ['Azure_openai_api_version'],\\r    azure_endpoint=os.environ['app_OPENAI_BASE'],\\r    streaming=True,\\r    verbose=True\\r)\\r\\rdef llm_invoke(data, user_prompt):\\r\\r    try:\\r\\r        prompt = ChatPromptTemplate.from_template(user_prompt)\\r\\r        chain = prompt | llm\\r\\r        try:\\r\\r            response = chain.invoke({\\""data\\"": data})\\r\\r            formatted_response = response.content\\r\\r            logger.info(formatted_response)\\r\\r        except:\\r\\r            formatted_response = \\""API overloaded, please try again after sometime...\\""\\r\\r        return formatted_response\\r\\r    except Exception as e:\\r\\r        logger.error(f\\""Exception in llm_invoke method: {e}\\"")""]},""position_x"":""606"",""position_y"":""91"",""connectors"":[],""inputEndpoints"":[""dataset1"",""dataset2"",""dataset3""],""outputEndpoints"":[""out""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n""},""context"":[]},{""id"":""cbYbV"",""alias"":""Sessions"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""get_mysql_connection"",""requirements"":"""",""params"":[],""script"":[""Leap_Project_Id = 2\\rLeap_Project_Name = 'leo1311'\\rLeap_URL = os.environ['referrer']\\rflag=False\\r\\rdef get_mysql_connection():\\r\\r    mydb = mysql.connector.connect(\\r        host=os.environ['app_DB_HOST'],\\r        user=os.environ['app_mysql_user'],\\r        password=os.environ['app_DB_PASSWORD'],\\r        database=os.environ['Data_DB'],\\r        port=os.environ['Data_DB_port']\\r    )\\r    \\r    logger.info(\\""Connection Successful----\\"",mydb)\\r    mycursor = mydb.cursor(dictionary=True)\\r    return mydb, mycursor\\r\\r\\rdef db_start_chat_session(chat_user_id: str, session_id: str, chat_time: str, date: str):\\r\\r    try:\\r\\r        table_name = \\""chatsession\\""\\r\\r        connection, cursor = get_mysql_connection()\\r\\r        # No existing record with the same chat_user_id and session_id, insert the new record\\r\\r        insert_query = f\\""INSERT INTO {table_name}  SELECT '{chat_user_id}', '{session_id}','{chat_time}', '{date}' ,'' AS t1 WHERE NOT EXISTS (SELECT session_id FROM {table_name} WHERE chat_user_id = '{chat_user_id}' AND session_id = '{session_id}')\\""\\r\\r        cursor.execute(insert_query)\\r\\r        connection.commit()\\r\\r        connection.close()\\r\\r        sys.exit()\\r\\r    except Exception as e:\\r\\r        logger.error(f\\""Error inserting record: {e}....\\"")\\r\\r\\r\\r\\r\\rdef db_get_user_chat_history(chat_user_id: str):\\r\\r    table_name = \\""chatsession\\""\\r\\r    connection, cursor = get_mysql_connection()\\r\\r    cursor.execute(\\r\\r        f\\""SELECT chat_time, date as chat_date, summary, session_id FROM {table_name} WHERE chat_user_id='{chat_user_id}'\\"")\\r\\r    rows = cursor.fetchall()\\r\\r    return rows\\r\\r\\r\\r\\r\\rdef db_update_chat_summary(session_id: str, summary: str):\\r\\r    try:\\r\\r        table_name = \\""chatsession\\""\\r\\r        connection, cursor = get_mysql_connection()\\r\\r        insert_query = f\\""Update {table_name} set summary = %s   WHERE  session_id = %s\\""\\r\\r        values = (summary, session_id)\\r\\r        cursor.execute(insert_query, values)\\r\\r        connection.commit()\\r\\r        connection.close()\\r\\r    except Exception as e:\\r\\r        connection.close()\\r\\r        logger.error(f\\""Error inserting record: {e}....\\"")\\r\\r\\r\\r\\r\\rdef db_add_chat_question_response(session_id, chat_user_query, query_time, chat_chain_of_thoughts,\\r\\r                                  chat_response_time, response,\\r\\r                                  response_time):\\r\\r    # Connect to the SQLite database\\r    # try:\\r    table_name = \\""chathistory\\""\\r    connection, cursor = get_mysql_connection()\\r    print(\\""Connected---\\"")\\r\\r    default_response = 'API overloaded, please try again after sometime...'\\r\\r    if response != default_response:\\r\\r        chat_user_query = chat_user_query.replace('\\""', '')\\r\\r        query = f\\""\\""\\""INSERT INTO {table_name} ( session_id, chat_user_query,query_time,chat_chain_of_thoughts,chat_response_time, message,response_time) \\r\\r                        VALUES (%s,%s,%s,%s,%s,%s,%s)\\""\\""\\""\\r\\r        values = (\\r\\r            session_id, chat_user_query, query_time, json.dumps(chat_chain_of_thoughts), chat_response_time,\\r\\r            response, response_time)\\r            \\r        print(\\""Query----\\"",query)\\r        print(\\""values----\\"",values)\\r        cursor.execute(query, values)\\r\\r        # Commit the changes and close the connection\\r\\r    connection.commit()\\r\\r    connection.close()\\r\\r    summary = fetch_session_records_summary(session_id)\\r\\r    db_update_chat_summary(session_id, summary)\\r\\r    # except Exception as e:\\r    print(response)\\r\\r    # sys.exit()\\r\\r\\r\\rdef db_fetch_chat_session_records(chat_user_id, session_id):\\r\\r    try:\\r\\r        table_name = \\""chathistory\\""\\r\\r        connection, cursor = get_mysql_connection()\\r\\r        # Fetch data from the table based on session_id\\r\\r        query = f\\""\\""\\""SELECT id, session_id, chat_user_query,query_time,chat_chain_of_thoughts,chat_response_time, message,response_time,source_references as `references` FROM {table_name} WHERE session_id='{session_id}'\\""\\""\\""\\r\\r        cursor.execute(query)\\r\\r        rows = cursor.fetchall()\\r\\r        # Convert rows to the desired format\\r\\r        connection.close()\\r\\r        for r in rows:\\r\\r            r['chat_chain_of_thoughts'] = json.loads(r['chat_chain_of_thoughts'])\\r\\r            r['references'] = json.loads(r['references'])\\r\\r        return rows\\r\\r    except Exception as e:\\r\\r        connection.close()\\r\\r        logger.error(f\\""Error fetching records: {e}...\\"")\\r\\r\\r\\r\\r\\rdef fetch_session_records_summary(session_id):\\r\\r    try:\\r\\r        table_name2 = \\""chathistory\\""\\r\\r        connection, cursor = get_mysql_connection()\\r\\r        # Limiting to 2 records per session_id...\\r\\r        cursor.execute(\\r\\r            f\\""SELECT chat_user_query FROM {table_name2} WHERE session_id='{session_id}' LIMIT 6\\"")\\r\\r        user_questions = cursor.fetchall()\\r\\r        summary_prompt = \\""\\""\\""\\r\\r                        generate the summary of Topic discussed in the context in 20 words. Remember to not summerize with extra unnecessary words in summary.\\r\\r                        {data} \\r\\r                        \\""\\""\\""\\r\\r        chat_summary = llm_invoke(user_questions, summary_prompt)\\r\\r        return chat_summary\\r\\r    except Exception as e:\\r\\r        connection.close()\\r\\r        logger.error(f\\""Error fetching session records: {e}...\\"")\\r\\r\\r\\r\\r\\rdef db_fetch_chat_time(session_id):\\r\\r    try:\\r\\r        table_name = \\""chatsession\\""\\r\\r        connection, cursor = get_mysql_connection()\\r\\r        cursor.execute(f\\""SELECT chat_time FROM {table_name} WHERE session_id='{session_id}'\\"")\\r\\r        row = list(cursor.fetchone().values())\\r\\r        connection.close()\\r\\r        return row[0]\\r\\r    except Exception as e:\\r\\r        connection.close()\\r\\r        logger.error(f\\""Error fetching chat time: {e}...\\"")""]},""position_x"":""276"",""position_y"":""188"",""connectors"":[],""inputEndpoints"":[""dataset1"",""dataset2"",""dataset3""],""outputEndpoints"":[""out""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n""},""context"":[]}],""pipeline_attributes"":[{""name"":""usedSecrets"",""value"":""app_OPENAI_API_KEY""},{""name"":""usedSecrets"",""value"":""app_OPENAI_BASE""},{""name"":""usedSecrets"",""value"":""app_DB_HOST""},{""name"":""usedSecrets"",""value"":""app_DB_PASSWORD""},{""name"":""usedSecrets"",""value"":""Leap_access_token""},{""name"":""usedSecrets"",""value"":""app_mysql_user""},{""name"":""usedSecrets"",""value"":""SNOW_username""},{""name"":""usedSecrets"",""value"":""SNOW_password""},{""name"":""usedSecrets"",""value"":""SNOW_url""}],""environment"":[{""name"":""ICAP_URL"",""value"":""http://victlptst-42:5000""},{""name"":""Data_DB_port"",""value"":""3307""},{""name"":""Data_DB"",""value"":""leap_7000_ref_data""},{""name"":""Confluence_search_url"",""value"":""http://victadpst-38:8080/ConfluenceSearch""},{""name"":""Azure_openai_api_version"",""value"":""2023-07-01-preview""},{""name"":""deploymentName"",""value"":""gtp35turbo""},{""name"":""referrer"",""value"":""https://leap2:7000""},{""name"":""Leap_Project_Name"",""value"":""leo1311""},{""name"":""no_proxy"",""value"":""leap2""}],""default_runtime"":""{\\""dsAlias\\"":\\""VM-27\\"",\\""dsName\\"":\\""LEOVM-2757480\\"",\\""type\\"":\\""REMOTE\\""}""}","admin","Leo Chatbot","2024-11-18 16:17:24","LEOLCHTB10964","leo1311","DragNDropLite","388",\N,"chain",NULL,"\0","0"
"admin","2024-08-08 07:45:46.889000","","","NULL","{\"elements\":[{\"attributes\":{\"filetype\":\"Jython\",\"files\":[\"LEOCDGNR66088_leo1311.py\"],\"arguments\":[{\"name\":\"scriptPath\",\"value\":\"\",\"type\":\"Text\",\"alias\":\"\",\"index\":\"1\"},{\"name\":\"pipelineName\",\"value\":\"\",\"type\":\"Text\",\"alias\":\"\",\"index\":\"2\"}],\"dataset\":[]}}]}","admin","CodeGeneration_DragNDrop","2024-08-08 12:57:43","LEOCDGNR66088","leo1311","NativeScript","12","NULL","pipeline","NULL","\0","0"
"admin","2024-12-04 05:52:36.962000","\0","",\N,"{""elements"":[{""id"":""uvuwP"",""alias"":""DatasetExtractor"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""DatasetExtractor"",""requirements"":""translatepy"",""params"":[],""script"":[""import os\\r\\rimport json\\r\\rimport requests\\r\\rimport shutil\\r\\rimport boto3\\r\\rimport stat\\r\\rdatasetid_param = os.environ['datasetId']\\rorg_param = os.environ['org']\\r\\r\\rdef getdatasetconfig(dataset_id:str, organization:str):\\r\\r        '''\\r\\r        call ai-plat api to get dataset config\\r\\r        return {dataset_config}\\r\\r        '''  \\r\\r        try:\\r            api_referer=os.environ[\\""API_URL\\""]\\r            url = f\\""{api_referer}/api/aip/services/fetchDatasetDetails/{dataset_id}/{organization}\\""\\r\\r            headers = {\\r\\r            'access-token': os.environ.get(\\""app_access_token\\""),\\r\\r            'Project':'2'\\r\\r            }\\r\\r            response = requests.request(\\""GET\\"", url, headers=headers, verify=False)\\r\\r            dataset_config = json.loads(response.text)\\r\\r            return dataset_config\\r\\r        except Exception as e:\\r\\r            print('Exception in getdatasetconfig as: ', e)\\r\\r            raise e\\r\\rdef get_keyconfig(organization:str):\\r\\r    try: \\r        api_referer=os.environ.get(\\""API_URL\\"")\\r\\r        url = f\\""{api_referer}/api/aip/service/v1/datasources/all?org={organization}\\""\\r\\r        headers = {\\r\\r        'Project': '2',\\r\\r        'access-token': os.environ.get(\\""app_access_token\\""),\\r\\r        }\\r\\r        response = requests.request(\\""GET\\"", url, headers=headers, verify=False)\\r\\r        key_config = json.loads(response.text)\\r\\r        return key_config\\r\\r    except Exception as e:\\r\\r        print('Exception in get_keyconfig as: ', e)\\r\\r        raise e\\r\\r \\r\\r\\r\\rdef s3_download_data(end_point_url,access_key,secret_key,bucket, obj_key, local_path):\\r\\r    \\""\\""\\""\\r\\r    Download a folder from S3 to a local path.\\r\\r    \\""\\""\\""\\r\\r    session = boto3.session.Session()\\r\\r    s3c = session.client(\\r\\r        aws_access_key_id=access_key,\\r\\r        aws_secret_access_key=secret_key,\\r\\r        endpoint_url=end_point_url,\\r\\r        service_name=\\""s3\\"",\\r\\r        use_ssl=False,\\r\\r    )    \\r\\r    resource = boto3.resource(\\r\\r        aws_access_key_id=access_key,\\r\\r        aws_secret_access_key=secret_key,\\r\\r        endpoint_url=end_point_url,\\r\\r        service_name=\\""s3\\"",\\r\\r        use_ssl=False,\\r        )\\r    # List all objects in the folder\\r\\r    response = s3c.list_objects_v2(Bucket=bucket, Prefix=obj_key)\\r\\r    objects = response.get('Contents', [])\\r\\r    for obj in objects:\\r\\r        key = obj['Key']\\r        print(\\""Downloading file: \\"", key)\\r        file_path = os.path.join(local_path, key)\\r        try:\\r            if not os.path.exists(os.path.dirname(file_path)):\\r                os.makedirs(os.path.dirname(file_path))\\r            if not obj.get('Key').endswith('/'):\\r                resource.meta.client.download_file(bucket, obj.get('Key'), file_path)\\r                print(f\\""Downloaded {key} to {file_path}\\"")\\r        except PermissionError as e:\\r            print(f\\""PermissionError: {e} - Skipping {key}\\"")    \\r\\rdef DatasetExtractor():    #python-script Data\\r\\r    #get dataset configurations \\r\\r    datasetcofig = getdatasetconfig(dataset_id=datasetid_param, organization=org_param)   \\r\\r    dataset_type = datasetcofig['datasource']['type']  \\r\\r    print(\\""dataset_type\\"",dataset_type)\\r\\r    if dataset_type == 'S3':\\r\\r        connection_dict = json.loads(datasetcofig['datasource']['connectionDetails'])\\r        secret_key= connection_dict['secretKey']\\r        os.environ['AWS_SECRET_ACCESS_KEY'] = secret_key\\r        access_key = connection_dict['accessKey']\\r        os.environ['AWS_ACCESS_KEY_ID'] = access_key\\r        region = connection_dict['Region']\\r        os.environ['AWS_REGION'] = region\\r        url = connection_dict['url']\\r        os.environ['AWS_ENDPOINT_URL'] = url\\r\\r        print(connection_dict)\\r\\r        print(\\""Fetched Connection Details\\"")\\r\\r        s3_access_key = connection_dict['accessKey']\\r\\r        s3_secret_key = connection_dict['secretKey']\\r\\r        s3_end_point_url = connection_dict['url'] \\r\\r        attribute = json.loads(datasetcofig['attributes'])\\r\\r        bucket = attribute['bucket']               \\r        os.environ['Bucket_Name'] = bucket\\r        path = attribute['path']   \\r\\r        obj_key = attribute['object']  \\r\\r        key = f'{path}/{obj_key}'\\r\\r        local_path = r\\""C:\\\\github\\\\data\\""\\r\\r        def on_rm_error(func, path, exc_info):\\r\\r            if not os.access(path, os.W_OK):\\r\\r                os.chmod(path, stat.S_IWUSR)\\r\\r                func(path)\\r\\r            else:\\r\\r                raise\\r\\r        if os.path.exists(local_path):\\r\\r            shutil.rmtree(local_path, onerror=on_rm_error)\\r\\r        if not os.path.exists(local_path):\\r\\r            os.makedirs(local_path)\\r\\r        os.listdir(local_path)\\r\\r        s3_download_data(end_point_url = s3_end_point_url, access_key = s3_access_key, secret_key=s3_secret_key, bucket = bucket, obj_key = key, local_path = local_path)\\r\\r    elif dataset_type == 'GIT':  \\r\\r        connection_dict = json.loads(datasetcofig['datasource']['connectionDetails'])\\r\\r        bucketname= connection_dict.get('bucketname')\\r        \\r        os.environ['Bucket_Name'] = bucketname\\r\\r        bucketPath = connection_dict.get('bucketPath')\\r\\r        attribute=json.loads(datasetcofig['attributes'])\\r\\r        url=attribute['url']\\r\\r        repo_name=url.split('/')[-1].replace('.git','')\\r        \\r        if bucketPath != \\""\\"":\\r            key= bucketPath + '/' + repo_name\\r        else:\\r             key= repo_name\\r\\r        s3ConnectionId= connection_dict['datasource']\\r\\r        response = get_keyconfig(organization=org_param)\\r\\r        for i in response:\\r\\r            if i.get('name') == s3ConnectionId:\\r\\r                connection_dict = json.loads(i.get('connectionDetails'))\\r\\r                secret_key= connection_dict['secretKey']\\r                os.environ['AWS_SECRET_ACCESS_KEY'] = secret_key\\r                access_key = connection_dict['accessKey']\\r                os.environ['AWS_ACCESS_KEY_ID'] = access_key\\r                region = connection_dict['Region']\\r                os.environ['AWS_REGION'] = region\\r                url = connection_dict['url']\\r                os.environ['AWS_ENDPOINT_URL'] = url\\r\\r                print(secret_key, access_key, region, url)\\r\\r        local_path = r\\""C:\\\\github\\\\data\\""\\r\\r        def on_rm_error(func, path, exc_info):\\r\\r            if not os.access(path, os.W_OK):\\r\\r                os.chmod(path, stat.S_IWUSR)\\r\\r                func(path)\\r\\r            else:\\r\\r                raise\\r\\r        if os.path.exists(local_path):\\r\\r            shutil.rmtree(local_path, onerror=on_rm_error)\\r\\r        if not os.path.exists(local_path):\\r\\r            os.makedirs(local_path)\\r\\r        print(os.listdir(local_path),\\""****************\\"")\\r\\r        s3_download_data(end_point_url = url, access_key = access_key, secret_key=secret_key, bucket = bucketname, obj_key = key, local_path = local_path)\\r        \\r        print(os.listdir(local_path),\\""****************\\"")\\r        \\r    return local_path""]},""position_x"":""155"",""position_y"":""32"",""connectors"":[{""type"":""source"",""endpoint"":""out1"",""position"":""RightMiddle"",""elementId"":""MUYsk"",""elementPosition"":""LeftMiddle""}],""inputEndpoints"":[""dataset1"",""dataset2""],""outputEndpoints"":[""out1"",""out2""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n""},""context"":[]},{""id"":""MUYsk"",""alias"":""process_folder"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""process_folder"",""requirements"":""openai==1.2.0"",""params"":[],""script"":[""import base64\\rimport requests\\rimport json\\rimport os\\rimport mimetypes\\rfrom pydub import AudioSegment\\rimport urllib3\\rimport pathlib\\rimport shutil\\rimport openai\\rimport boto3\\rfrom translatepy import Translator\\rfrom PyPDF2 import PdfReader\\rfrom docx import Document\\rfrom pptx import Presentation\\rfrom langchain_core.prompts import ChatPromptTemplate\\rfrom langchain_openai import AzureChatOpenAI\\rfrom langchain_core.prompts import ChatPromptTemplate\\r\\rurllib3.disable_warnings()\\rmodel = \\""whisper-m\\""\\ros.environ[model] = os.environ.get(\\""Transcribe_url\\"")\\r\\rdef summarize_text(text):\\r\\r    from langchain.chains.summarize import load_summarize_chain\\r    from langchain_text_splitters  import RecursiveCharacterTextSplitter\\r    from langchain.schema.document import Document\\r\\r    text_splitter = RecursiveCharacterTextSplitter()\\r    texts = text_splitter.split_text(text)\\r    docs = [Document(page_content=t) for t in texts]\\r\\r    llm = AzureChatOpenAI(\\r        openai_api_key= os.environ.get(\\""app_openai_api_key\\""), \\r        azure_endpoint = os.environ.get(\\""app_openai_api_base\\""), \\r        deployment_name='gpt-4', \\r        temperature=0, \\r        openai_api_version='2023-05-15')\\r    deployment_name = '''gpt-4'''\\r\\r    try:\\r\\r        user_prompt = \\""Give the five line summary on following data: {data}\\""\\r        prompt = ChatPromptTemplate.from_template(user_prompt)\\r        chain = prompt | llm \\r        response = chain.invoke({\\""data\\"": docs})\\r        result = response.content\\r        return result,deployment_name\\r\\r    except Exception as e:\\r        print(\\""Error in summarizing text: \\"", e)\\r        return None,deployment_name\\r\\r\\rdef process_folder(folder_path):\\r    print(f\\""Function called with folder_path: {folder_path}\\"")\\r    created_folders = []  # List to store the paths of the created .aip folders\\r    queue = []\\r\\r    print(\\""Starting folder path:\\"", folder_path)\\r\\r    queue.append(folder_path)\\r\\r    print(\\""Initial queue:\\"", queue)\\r\\r    translator = Translator()\\r\\r    print(\\""Translator initialized.\\"")\\r\\r    while len(queue) > 0:\\r\\r        current_folder = queue[0]\\r\\r        print(\\""Processing current folder:\\"", current_folder)\\r\\r        file_exist = False\\r\\r        for file_name in os.listdir(current_folder):\\r\\r            print(f\\""Checking file: {file_name} in folder: {current_folder}\\"")\\r\\r            if file_name in ['Translation', 'Transcribe']:  # Corrected condition to check individual strings\\r\\r                print(\\""Skipping transcribe or translation folder\\"")\\r\\r                continue\\r\\r            file_path = os.path.join(current_folder, file_name)\\r\\r            print('Checking file path:', file_path)\\r\\r            if os.path.isfile(file_path):\\r\\r                file_exist = True\\r\\r                print(f\\""Found file: {file_path}\\"")\\r\\r            elif not os.path.isfile(file_path) and not file_name.startswith('.'):\\r\\r                queue.append(os.path.join(current_folder, file_name))\\r\\r                print(f\\""Added folder to queue: {os.path.join(current_folder, file_name)}\\"")\\r\\r        if file_exist:\\r\\r            print(\\""File exists in current folder - Processing for summary:\\"", file_path)\\r\\r            summary_folder = os.path.join(current_folder,'.aip', 'Summary')\\r\\r            print(\\""Creating summary folder at:\\"", summary_folder)\\r\\r            os.makedirs(summary_folder, exist_ok=True)\\r\\r            created_folders.append(os.path.dirname(summary_folder))  # Add the created .aip folder path to the list\\r\\r            print(f\\""Added created folder to list: {os.path.dirname(summary_folder)}\\"")\\r\\r            for file_name in os.listdir(current_folder):\\r\\r                file_path = os.path.join(current_folder, file_name)\\r\\r                text_to_summarize = ''\\r\\r                if os.path.isfile(file_path):\\r\\r                    extension = os.path.splitext(file_name)[1]\\r\\r                    mimetype = mimetypes.guess_type(file_path)[0]\\r\\r                    print(f\\""Processing file: {file_name}, Extension: {extension}, Mimetype: {mimetype}\\"")\\r\\r                    if mimetype and ('audio' in mimetype or 'video' in mimetype):\\r\\r                        transcript_folder = os.path.join(current_folder,'.aip', 'Transcribe')\\r\\r                        print(\\""Transcript folder path:\\"", transcript_folder)\\r\\r                        transcript_path = os.path.join(transcript_folder, f\\""{os.path.splitext(file_name)[0]}.txt\\"")\\r\\r                        print(\\""Transcript file path:\\"", transcript_path)\\r\\r                        if os.path.exists(transcript_path):\\r\\r                            with open(transcript_path, 'r', encoding='utf-8') as f:\\r\\r                                transcript = f.read()\\r\\r                            text_to_summarize = transcript\\r\\r                            print(\\""Transcript read successfully.\\"")\\r\\r                        else:\\r\\r                            print(\\""Transcript not found for file:\\"", file_name)\\r\\r                    elif extension in ['.txt', '.pdf', '.docx', '.pptx','.py','.java','.c','.cpp','.html','.css','.js','.ts','.jsx','.tsx','.json','.xml','.yaml','.yml','.sql','.php','.rb','.sh','.bat','.ps1','.psm1','.psd1','.ps1xml','.clixml','.pssc','.cdxml','.xaml','.csv','.tsv','.ini','.inf','.reg','.md']:\\r\\r                        print(f\\""Reading content from {extension} file.\\"")\\r\\r                        if extension == \\"".txt\\"":\\r\\r                            with open(file_path, 'r', encoding='utf-8') as f:\\r\\r                                text_to_summarize = f.read()\\r\\r                            print(\\""Text read from .txt file.\\"")\\r\\r                        elif extension == \\"".pdf\\"":\\r\\r                            with open(file_path, 'rb') as f:\\r\\r                                pdf = PdfReader(f)\\r\\r                                text_to_summarize = \\"" \\"".join(page.extract_text() for page in pdf.pages)\\r\\r                            print(\\""Text read from .pdf file.\\"")\\r\\r                        elif extension == \\"".docx\\"":\\r\\r                            doc = Document(file_path)\\r\\r                            text_to_summarize = \\"" \\"".join(paragraph.text for paragraph in doc.paragraphs)\\r\\r                            print(\\""Text read from .docx file.\\"")\\r\\r                        elif extension == \\"".pptx\\"":\\r\\r                            pres = Presentation(file_path)\\r\\r                            text_to_summarize = \\"" \\"".join(\\r\\r                                \\"" \\"".join(shape.text for shape in slide.shapes if shape.has_text_frame) for slide in\\r\\r                                pres.slides)\\r\\r                            print(\\""Text read from .pptx file.\\"")\\r\\r                        elif extension == \\"".py\\"":\\r\\r                            with open(file_path, 'r', encoding='utf-8') as f:\\r\\r                                text_to_summarize = f.read()\\r\\r                            print(\\""Text read from .py file.\\"")\\r\\r                        elif extension == \\"".java\\"" or \\"".c\\"" or \\"".cpp\\"" or \\"".html\\"" or \\"".css\\"" or \\"".js\\"" or \\"".ts\\"" or \\"".jsx\\"" or \\"".tsx\\"" or \\"".json\\"" or \\"".xml\\"" or \\"".yaml\\"" or \\"".yml\\"" or \\"".sql\\"" or \\"".php\\"" or \\"".rb\\"" or \\"".sh\\"" or \\"".bat\\"" or \\"".ps1\\"" or \\"".psm1\\"" or \\"".psd1\\"" or \\"".ps1xml\\"" or \\"".clixml\\"" or \\"".pssc\\"" or \\"".cdxml\\"" or \\"".xaml\\"" or \\"".csv\\"" or \\"".tsv\\"" or \\"".ini\\"" or \\"".inf\\"" or \\"".reg\\"":\\r\\r                            with open(file_path, 'r', encoding='utf-8') as f:\\r\\r                                text_to_summarize = f.read()\\r\\r                            print(\\""Text read from .java file.\\"")\\r\\r                        elif extension == \\"".md\\"":\\r\\r                            print(\\""Reading content from .md file.\\"")\\r\\r                            with open(file_path, 'r', encoding='utf-8') as f:\\r\\r                                text_to_summarize = f.read()\\r\\r                                \\r\\r                            print(\\""Text read from .md file.\\"",text_to_summarize)\\r\\r   \\r\\r                        else:\\r\\r                            print(f\\""Skipping file {file_name} as it is not supported\\"")\\r\\r                            continue\\r\\r                    if text_to_summarize != '':\\r\\r                        try:\\r\\r                            print(\\""Detecting language of the text.\\"")\\r\\r                            language = translator.language(text_to_summarize[0:100])\\r\\r                            print(f\\""Detected language: {language.result}\\"")\\r\\r                            if str(language.result) != \\""eng\\"":\\r\\r                                print(\\""Translating text to English.\\"")\\r\\r                                text_to_summarize = translator.translate(text_to_summarize, \\""English\\"").result\\r\\r                        except Exception as e:\\r\\r                            print(f\\""Translation failed with error: {e}\\"")\\r\\r                        print(\\""Summarizing text.\\"")\\r\\r                        summary, model_name = summarize_text(text_to_summarize)\\r\\r                        if summary is not None:\\r\\r                            summary = summary[:-10]\\r\\r                        else:\\r\\r                            summary = \\""\\""\\r\\r                        output_filename = os.path.splitext(file_name)[0] + \\"".txt\\""\\r                        output_file_path = os.path.join(summary_folder, f\\""{os.path.splitext(file_name)[0]}.txt\\"")\\r                        with open(output_file_path, 'w', encoding='utf-8') as f:\\r\\r                            f.write(summary)\\r\\r                            f.write(\\"". Model name: \\"" + model_name)\\r\\r                        print(f\\""Summarized file {file_name} has been saved to {output_file_path}\\"")\\r\\r                        file_path = output_file_path\\r\\r        else:\\r\\r            print(\\""No files found in current folder, moving to next.\\"")\\r        folder_path1 = queue[0]\\r        path1 = os.path.join(folder_path1, '.aip', 'Summary')\\r        if os.path.exists(path1):\\r            if os.listdir(path1):\\r                text_data = \\""\\""\\r                for file_name in os.listdir(path1):\\r                    if file_name.endswith(\\"".txt\\""):\\r                        file_path = os.path.join(path1, file_name)\\r                        with open(file_path, 'r', encoding='utf-8') as f:\\r                            text_data += \\"" \\"" + f.read()\\r                summary, model_name = summarize_text(text_data)\\r                output_filename = os.path.basename(folder_path1)+ \\"".txt\\""\\r                output_folder = os.path.dirname(folder_path1)\\r                summary_folder = os.path.join(output_folder, '.aip', 'Summary')\\r                if not os.path.exists(summary_folder):\\r                    os.makedirs(summary_folder)\\r                \\r                output_file_path = os.path.join(summary_folder, output_filename+\\"".txt\\"")\\r                with open(output_file_path, 'w', encoding='utf-8') as f:\\r                    f.write(summary)\\r                    f.write(\\"". Model name: \\"" + model_name)\\r\\r        queue.pop(0)\\r\\r        print(\\""Moving to next folder in queue.\\"")\\r\\r    print(\\""Processing complete.\\"")\\r\\r    return folder_path\\r\\r\\r\\r""]},""position_x"":""382"",""position_y"":""32"",""connectors"":[{""type"":""target"",""endpoint"":""dataset1"",""position"":""LeftMiddle"",""elementId"":""uvuwP"",""elementPosition"":""RightMiddle""},{""type"":""source"",""endpoint"":""out1"",""position"":""RightMiddle"",""elementId"":""yUbfX"",""elementPosition"":""LeftMiddle""}],""inputEndpoints"":[""dataset1"",""dataset2""],""outputEndpoints"":[""out1"",""out2""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n""},""context"":[{""FunctionName"":""DatasetExtractor"",""requirements"":""translatepy"",""params"":[],""script"":[""import os\\r\\rimport json\\r\\rimport requests\\r\\rimport shutil\\r\\rimport boto3\\r\\rimport stat\\r\\rdatasetid_param = os.environ['datasetId']\\rorg_param = os.environ['org']\\r\\r\\rdef getdatasetconfig(dataset_id:str, organization:str):\\r\\r        '''\\r\\r        call ai-plat api to get dataset config\\r\\r        return {dataset_config}\\r\\r        '''  \\r\\r        try:\\r            api_referer=os.environ[\\""API_URL\\""]\\r            url = f\\""{api_referer}/api/aip/services/fetchDatasetDetails/{dataset_id}/{organization}\\""\\r\\r            headers = {\\r\\r            'access-token': os.environ.get(\\""app_access_token\\""),\\r\\r            'Project':'2'\\r\\r            }\\r\\r            response = requests.request(\\""GET\\"", url, headers=headers, verify=False)\\r\\r            dataset_config = json.loads(response.text)\\r\\r            return dataset_config\\r\\r        except Exception as e:\\r\\r            print('Exception in getdatasetconfig as: ', e)\\r\\r            raise e\\r\\rdef get_keyconfig(organization:str):\\r\\r    try: \\r        api_referer=os.environ.get(\\""API_URL\\"")\\r\\r        url = f\\""{api_referer}/api/aip/service/v1/datasources/all?org={organization}\\""\\r\\r        headers = {\\r\\r        'Project': '2',\\r\\r        'access-token': os.environ.get(\\""app_access_token\\""),\\r\\r        }\\r\\r        response = requests.request(\\""GET\\"", url, headers=headers, verify=False)\\r\\r        key_config = json.loads(response.text)\\r\\r        return key_config\\r\\r    except Exception as e:\\r\\r        print('Exception in get_keyconfig as: ', e)\\r\\r        raise e\\r\\r \\r\\r\\r\\rdef s3_download_data(end_point_url,access_key,secret_key,bucket, obj_key, local_path):\\r\\r    \\""\\""\\""\\r\\r    Download a folder from S3 to a local path.\\r\\r    \\""\\""\\""\\r\\r    session = boto3.session.Session()\\r\\r    s3c = session.client(\\r\\r        aws_access_key_id=access_key,\\r\\r        aws_secret_access_key=secret_key,\\r\\r        endpoint_url=end_point_url,\\r\\r        service_name=\\""s3\\"",\\r\\r        use_ssl=False,\\r\\r    )    \\r\\r    resource = boto3.resource(\\r\\r        aws_access_key_id=access_key,\\r\\r        aws_secret_access_key=secret_key,\\r\\r        endpoint_url=end_point_url,\\r\\r        service_name=\\""s3\\"",\\r\\r        use_ssl=False,\\r        )\\r    # List all objects in the folder\\r\\r    response = s3c.list_objects_v2(Bucket=bucket, Prefix=obj_key)\\r\\r    objects = response.get('Contents', [])\\r\\r    for obj in objects:\\r\\r        key = obj['Key']\\r        print(\\""Downloading file: \\"", key)\\r        file_path = os.path.join(local_path, key)\\r        try:\\r            if not os.path.exists(os.path.dirname(file_path)):\\r                os.makedirs(os.path.dirname(file_path))\\r            if not obj.get('Key').endswith('/'):\\r                resource.meta.client.download_file(bucket, obj.get('Key'), file_path)\\r                print(f\\""Downloaded {key} to {file_path}\\"")\\r        except PermissionError as e:\\r            print(f\\""PermissionError: {e} - Skipping {key}\\"")    \\r\\rdef DatasetExtractor():    #python-script Data\\r\\r    #get dataset configurations \\r\\r    datasetcofig = getdatasetconfig(dataset_id=datasetid_param, organization=org_param)   \\r\\r    dataset_type = datasetcofig['datasource']['type']  \\r\\r    print(\\""dataset_type\\"",dataset_type)\\r\\r    if dataset_type == 'S3':\\r\\r        connection_dict = json.loads(datasetcofig['datasource']['connectionDetails'])\\r        secret_key= connection_dict['secretKey']\\r        os.environ['AWS_SECRET_ACCESS_KEY'] = secret_key\\r        access_key = connection_dict['accessKey']\\r        os.environ['AWS_ACCESS_KEY_ID'] = access_key\\r        region = connection_dict['Region']\\r        os.environ['AWS_REGION'] = region\\r        url = connection_dict['url']\\r        os.environ['AWS_ENDPOINT_URL'] = url\\r\\r        print(connection_dict)\\r\\r        print(\\""Fetched Connection Details\\"")\\r\\r        s3_access_key = connection_dict['accessKey']\\r\\r        s3_secret_key = connection_dict['secretKey']\\r\\r        s3_end_point_url = connection_dict['url'] \\r\\r        attribute = json.loads(datasetcofig['attributes'])\\r\\r        bucket = attribute['bucket']               \\r        os.environ['Bucket_Name'] = bucket\\r        path = attribute['path']   \\r\\r        obj_key = attribute['object']  \\r\\r        key = f'{path}/{obj_key}'\\r\\r        local_path = r\\""C:\\\\github\\\\data\\""\\r\\r        def on_rm_error(func, path, exc_info):\\r\\r            if not os.access(path, os.W_OK):\\r\\r                os.chmod(path, stat.S_IWUSR)\\r\\r                func(path)\\r\\r            else:\\r\\r                raise\\r\\r        if os.path.exists(local_path):\\r\\r            shutil.rmtree(local_path, onerror=on_rm_error)\\r\\r        if not os.path.exists(local_path):\\r\\r            os.makedirs(local_path)\\r\\r        os.listdir(local_path)\\r\\r        s3_download_data(end_point_url = s3_end_point_url, access_key = s3_access_key, secret_key=s3_secret_key, bucket = bucket, obj_key = key, local_path = local_path)\\r\\r    elif dataset_type == 'GIT':  \\r\\r        connection_dict = json.loads(datasetcofig['datasource']['connectionDetails'])\\r\\r        bucketname= connection_dict.get('bucketname')\\r        \\r        os.environ['Bucket_Name'] = bucketname\\r\\r        bucketPath = connection_dict.get('bucketPath')\\r\\r        attribute=json.loads(datasetcofig['attributes'])\\r\\r        url=attribute['url']\\r\\r        repo_name=url.split('/')[-1].replace('.git','')\\r        \\r        if bucketPath != \\""\\"":\\r            key= bucketPath + '/' + repo_name\\r        else:\\r             key= repo_name\\r\\r        s3ConnectionId= connection_dict['datasource']\\r\\r        response = get_keyconfig(organization=org_param)\\r\\r        for i in response:\\r\\r            if i.get('name') == s3ConnectionId:\\r\\r                connection_dict = json.loads(i.get('connectionDetails'))\\r\\r                secret_key= connection_dict['secretKey']\\r                os.environ['AWS_SECRET_ACCESS_KEY'] = secret_key\\r                access_key = connection_dict['accessKey']\\r                os.environ['AWS_ACCESS_KEY_ID'] = access_key\\r                region = connection_dict['Region']\\r                os.environ['AWS_REGION'] = region\\r                url = connection_dict['url']\\r                os.environ['AWS_ENDPOINT_URL'] = url\\r\\r                print(secret_key, access_key, region, url)\\r\\r        local_path = r\\""C:\\\\github\\\\data\\""\\r\\r        def on_rm_error(func, path, exc_info):\\r\\r            if not os.access(path, os.W_OK):\\r\\r                os.chmod(path, stat.S_IWUSR)\\r\\r                func(path)\\r\\r            else:\\r\\r                raise\\r\\r        if os.path.exists(local_path):\\r\\r            shutil.rmtree(local_path, onerror=on_rm_error)\\r\\r        if not os.path.exists(local_path):\\r\\r            os.makedirs(local_path)\\r\\r        print(os.listdir(local_path),\\""****************\\"")\\r\\r        s3_download_data(end_point_url = url, access_key = access_key, secret_key=secret_key, bucket = bucketname, obj_key = key, local_path = local_path)\\r        \\r        print(os.listdir(local_path),\\""****************\\"")\\r        \\r    return local_path""]}]},{""id"":""yUbfX"",""alias"":""Upload Data"",""name"":""Python Script"",""classname"":""PythonScriptConfig"",""category"":""BaseConfig"",""attributes"":{""FunctionName"":""uploadData"",""requirements"":"""",""params"":[],""script"":[""import boto3\\r\\rimport os\\r\\rimport logging as LOGGER\\r\\rdef uploadData(path):\\r    print(\\""path------------\\"",path)\\r\\r    try:\\r        secret_key = os.environ['AWS_SECRET_ACCESS_KEY']\\r        access_key = os.environ['AWS_ACCESS_KEY_ID']\\r        region = os.environ['AWS_REGION']\\r        bucket = os.environ['Bucket_Name']\\r        url = os.environ['AWS_ENDPOINT_URL']\\r        print(\\""secret_key------\\"",secret_key)\\r        print(\\""access_key----\\"",access_key)\\r        print(\\""region--------\\"",region)\\r        print(\\""bucket-------\\"",bucket)\\r        print(\\""url-----------\\"",url)\\r\\r        session = boto3.session.Session()\\r\\r        s3c = session.client(\\r\\r            aws_access_key_id=access_key,\\r\\r            aws_secret_access_key=secret_key,\\r\\r            endpoint_url=url,\\r\\r            service_name=\\""s3\\"",\\r\\r            use_ssl=False,\\r\\r        )\\r        print(\\""s3c==========\\"",s3c)\\r\\r        for root, dirs, files in os.walk(path):\\r\\r            for file in files:\\r\\r                local_path = os.path.join(root, file)\\r\\r                relative_path = os.path.relpath(local_path, path)\\r\\r\\r\\r                \\r\\r                # Check if the relative path contains a directory separator\\r\\r                if '/' in relative_path:\\r\\r                    s3_folder = os.path.dirname(relative_path)\\r\\r                    response = s3c.list_objects_v2(Bucket=bucket, Prefix=s3_folder + '/')\\r\\r                    s3c.put_object(Bucket=bucket, Key=s3_folder + '/')\\r\\r                else:\\r\\r                    # If the file is in the root directory, don't create an extra folder\\r\\r                    s3_folder = None\\r\\r                s3_path = os.path.join(\\""\\"", relative_path).replace(\\""\\\\\\\\\\"", \\""/\\"")\\r\\r\\r\\r                s3c.upload_file(local_path, bucket, s3_path)\\r\\r        print(\\""file got updated\\"")\\r\\r    except Exception as e:\\r\\r        LOGGER.error(e)\\r\\r        return False\\r\\r    return True""]},""position_x"":""617"",""position_y"":""32"",""connectors"":[{""type"":""target"",""endpoint"":""dataset1"",""position"":""LeftMiddle"",""elementId"":""MUYsk"",""elementPosition"":""RightMiddle""}],""inputEndpoints"":[""dataset1"",""dataset2""],""outputEndpoints"":[""out1"",""out2""],""formats"":{""FunctionName"":""text"",""requirements"":""textarea"",""params"":""list"",""script"":""textarea""},""codeGeneration"":{""imports"":[],""script"":""\\n\\n\\n\\n\\n\\n""},""context"":[{""FunctionName"":""process_folder"",""requirements"":""openai==1.2.0"",""params"":[],""script"":[""import base64\\rimport requests\\rimport json\\rimport os\\rimport mimetypes\\rfrom pydub import AudioSegment\\rimport urllib3\\rimport pathlib\\rimport shutil\\rimport openai\\rimport boto3\\rfrom translatepy import Translator\\rfrom PyPDF2 import PdfReader\\rfrom docx import Document\\rfrom pptx import Presentation\\rfrom langchain_core.prompts import ChatPromptTemplate\\rfrom langchain_openai import AzureChatOpenAI\\rfrom langchain_core.prompts import ChatPromptTemplate\\r\\rurllib3.disable_warnings()\\rmodel = \\""whisper-m\\""\\ros.environ[model] = os.environ.get(\\""Transcribe_url\\"")\\r\\rdef summarize_text(text):\\r\\r    from langchain.chains.summarize import load_summarize_chain\\r    from langchain_text_splitters  import RecursiveCharacterTextSplitter\\r    from langchain.schema.document import Document\\r\\r    text_splitter = RecursiveCharacterTextSplitter()\\r    texts = text_splitter.split_text(text)\\r    docs = [Document(page_content=t) for t in texts]\\r\\r    llm = AzureChatOpenAI(\\r        openai_api_key= os.environ.get(\\""app_openai_api_key\\""), \\r        azure_endpoint = os.environ.get(\\""app_openai_api_base\\""), \\r        deployment_name='gpt-4', \\r        temperature=0, \\r        openai_api_version='2023-05-15')\\r    deployment_name = '''gpt-4'''\\r\\r    try:\\r\\r        user_prompt = \\""Give the five line summary on following data: {data}\\""\\r        prompt = ChatPromptTemplate.from_template(user_prompt)\\r        chain = prompt | llm \\r        response = chain.invoke({\\""data\\"": docs})\\r        result = response.content\\r        return result,deployment_name\\r\\r    except Exception as e:\\r        print(\\""Error in summarizing text: \\"", e)\\r        return None,deployment_name\\r\\r\\rdef process_folder(folder_path):\\r    print(f\\""Function called with folder_path: {folder_path}\\"")\\r    created_folders = []  # List to store the paths of the created .aip folders\\r    queue = []\\r\\r    print(\\""Starting folder path:\\"", folder_path)\\r\\r    queue.append(folder_path)\\r\\r    print(\\""Initial queue:\\"", queue)\\r\\r    translator = Translator()\\r\\r    print(\\""Translator initialized.\\"")\\r\\r    while len(queue) > 0:\\r\\r        current_folder = queue[0]\\r\\r        print(\\""Processing current folder:\\"", current_folder)\\r\\r        file_exist = False\\r\\r        for file_name in os.listdir(current_folder):\\r\\r            print(f\\""Checking file: {file_name} in folder: {current_folder}\\"")\\r\\r            if file_name in ['Translation', 'Transcribe']:  # Corrected condition to check individual strings\\r\\r                print(\\""Skipping transcribe or translation folder\\"")\\r\\r                continue\\r\\r            file_path = os.path.join(current_folder, file_name)\\r\\r            print('Checking file path:', file_path)\\r\\r            if os.path.isfile(file_path):\\r\\r                file_exist = True\\r\\r                print(f\\""Found file: {file_path}\\"")\\r\\r            elif not os.path.isfile(file_path) and not file_name.startswith('.'):\\r\\r                queue.append(os.path.join(current_folder, file_name))\\r\\r                print(f\\""Added folder to queue: {os.path.join(current_folder, file_name)}\\"")\\r\\r        if file_exist:\\r\\r            print(\\""File exists in current folder - Processing for summary:\\"", file_path)\\r\\r            summary_folder = os.path.join(current_folder,'.aip', 'Summary')\\r\\r            print(\\""Creating summary folder at:\\"", summary_folder)\\r\\r            os.makedirs(summary_folder, exist_ok=True)\\r\\r            created_folders.append(os.path.dirname(summary_folder))  # Add the created .aip folder path to the list\\r\\r            print(f\\""Added created folder to list: {os.path.dirname(summary_folder)}\\"")\\r\\r            for file_name in os.listdir(current_folder):\\r\\r                file_path = os.path.join(current_folder, file_name)\\r\\r                text_to_summarize = ''\\r\\r                if os.path.isfile(file_path):\\r\\r                    extension = os.path.splitext(file_name)[1]\\r\\r                    mimetype = mimetypes.guess_type(file_path)[0]\\r\\r                    print(f\\""Processing file: {file_name}, Extension: {extension}, Mimetype: {mimetype}\\"")\\r\\r                    if mimetype and ('audio' in mimetype or 'video' in mimetype):\\r\\r                        transcript_folder = os.path.join(current_folder,'.aip', 'Transcribe')\\r\\r                        print(\\""Transcript folder path:\\"", transcript_folder)\\r\\r                        transcript_path = os.path.join(transcript_folder, f\\""{os.path.splitext(file_name)[0]}.txt\\"")\\r\\r                        print(\\""Transcript file path:\\"", transcript_path)\\r\\r                        if os.path.exists(transcript_path):\\r\\r                            with open(transcript_path, 'r', encoding='utf-8') as f:\\r\\r                                transcript = f.read()\\r\\r                            text_to_summarize = transcript\\r\\r                            print(\\""Transcript read successfully.\\"")\\r\\r                        else:\\r\\r                            print(\\""Transcript not found for file:\\"", file_name)\\r\\r                    elif extension in ['.txt', '.pdf', '.docx', '.pptx','.py','.java','.c','.cpp','.html','.css','.js','.ts','.jsx','.tsx','.json','.xml','.yaml','.yml','.sql','.php','.rb','.sh','.bat','.ps1','.psm1','.psd1','.ps1xml','.clixml','.pssc','.cdxml','.xaml','.csv','.tsv','.ini','.inf','.reg','.md']:\\r\\r                        print(f\\""Reading content from {extension} file.\\"")\\r\\r                        if extension == \\"".txt\\"":\\r\\r                            with open(file_path, 'r', encoding='utf-8') as f:\\r\\r                                text_to_summarize = f.read()\\r\\r                            print(\\""Text read from .txt file.\\"")\\r\\r                        elif extension == \\"".pdf\\"":\\r\\r                            with open(file_path, 'rb') as f:\\r\\r                                pdf = PdfReader(f)\\r\\r                                text_to_summarize = \\"" \\"".join(page.extract_text() for page in pdf.pages)\\r\\r                            print(\\""Text read from .pdf file.\\"")\\r\\r                        elif extension == \\"".docx\\"":\\r\\r                            doc = Document(file_path)\\r\\r                            text_to_summarize = \\"" \\"".join(paragraph.text for paragraph in doc.paragraphs)\\r\\r                            print(\\""Text read from .docx file.\\"")\\r\\r                        elif extension == \\"".pptx\\"":\\r\\r                            pres = Presentation(file_path)\\r\\r                            text_to_summarize = \\"" \\"".join(\\r\\r                                \\"" \\"".join(shape.text for shape in slide.shapes if shape.has_text_frame) for slide in\\r\\r                                pres.slides)\\r\\r                            print(\\""Text read from .pptx file.\\"")\\r\\r                        elif extension == \\"".py\\"":\\r\\r                            with open(file_path, 'r', encoding='utf-8') as f:\\r\\r                                text_to_summarize = f.read()\\r\\r                            print(\\""Text read from .py file.\\"")\\r\\r                        elif extension == \\"".java\\"" or \\"".c\\"" or \\"".cpp\\"" or \\"".html\\"" or \\"".css\\"" or \\"".js\\"" or \\"".ts\\"" or \\"".jsx\\"" or \\"".tsx\\"" or \\"".json\\"" or \\"".xml\\"" or \\"".yaml\\"" or \\"".yml\\"" or \\"".sql\\"" or \\"".php\\"" or \\"".rb\\"" or \\"".sh\\"" or \\"".bat\\"" or \\"".ps1\\"" or \\"".psm1\\"" or \\"".psd1\\"" or \\"".ps1xml\\"" or \\"".clixml\\"" or \\"".pssc\\"" or \\"".cdxml\\"" or \\"".xaml\\"" or \\"".csv\\"" or \\"".tsv\\"" or \\"".ini\\"" or \\"".inf\\"" or \\"".reg\\"":\\r\\r                            with open(file_path, 'r', encoding='utf-8') as f:\\r\\r                                text_to_summarize = f.read()\\r\\r                            print(\\""Text read from .java file.\\"")\\r\\r                        elif extension == \\"".md\\"":\\r\\r                            print(\\""Reading content from .md file.\\"")\\r\\r                            with open(file_path, 'r', encoding='utf-8') as f:\\r\\r                                text_to_summarize = f.read()\\r\\r                                \\r\\r                            print(\\""Text read from .md file.\\"",text_to_summarize)\\r\\r   \\r\\r                        else:\\r\\r                            print(f\\""Skipping file {file_name} as it is not supported\\"")\\r\\r                            continue\\r\\r                    if text_to_summarize != '':\\r\\r                        try:\\r\\r                            print(\\""Detecting language of the text.\\"")\\r\\r                            language = translator.language(text_to_summarize[0:100])\\r\\r                            print(f\\""Detected language: {language.result}\\"")\\r\\r                            if str(language.result) != \\""eng\\"":\\r\\r                                print(\\""Translating text to English.\\"")\\r\\r                                text_to_summarize = translator.translate(text_to_summarize, \\""English\\"").result\\r\\r                        except Exception as e:\\r\\r                            print(f\\""Translation failed with error: {e}\\"")\\r\\r                        print(\\""Summarizing text.\\"")\\r\\r                        summary, model_name = summarize_text(text_to_summarize)\\r\\r                        if summary is not None:\\r\\r                            summary = summary[:-10]\\r\\r                        else:\\r\\r                            summary = \\""\\""\\r\\r                        output_filename = os.path.splitext(file_name)[0] + \\"".txt\\""\\r                        output_file_path = os.path.join(summary_folder, f\\""{os.path.splitext(file_name)[0]}.txt\\"")\\r                        with open(output_file_path, 'w', encoding='utf-8') as f:\\r\\r                            f.write(summary)\\r\\r                            f.write(\\"". Model name: \\"" + model_name)\\r\\r                        print(f\\""Summarized file {file_name} has been saved to {output_file_path}\\"")\\r\\r                        file_path = output_file_path\\r\\r        else:\\r\\r            print(\\""No files found in current folder, moving to next.\\"")\\r        folder_path1 = queue[0]\\r        path1 = os.path.join(folder_path1, '.aip', 'Summary')\\r        if os.path.exists(path1):\\r            if os.listdir(path1):\\r                text_data = \\""\\""\\r                for file_name in os.listdir(path1):\\r                    if file_name.endswith(\\"".txt\\""):\\r                        file_path = os.path.join(path1, file_name)\\r                        with open(file_path, 'r', encoding='utf-8') as f:\\r                            text_data += \\"" \\"" + f.read()\\r                summary, model_name = summarize_text(text_data)\\r                output_filename = os.path.basename(folder_path1)+ \\"".txt\\""\\r                output_folder = os.path.dirname(folder_path1)\\r                summary_folder = os.path.join(output_folder, '.aip', 'Summary')\\r                if not os.path.exists(summary_folder):\\r                    os.makedirs(summary_folder)\\r                \\r                output_file_path = os.path.join(summary_folder, output_filename+\\"".txt\\"")\\r                with open(output_file_path, 'w', encoding='utf-8') as f:\\r                    f.write(summary)\\r                    f.write(\\"". Model name: \\"" + model_name)\\r\\r        queue.pop(0)\\r\\r        print(\\""Moving to next folder in queue.\\"")\\r\\r    print(\\""Processing complete.\\"")\\r\\r    return folder_path\\r\\r\\r\\r""]},{""FunctionName"":""DatasetExtractor"",""requirements"":""translatepy"",""params"":[],""script"":[""import os\\r\\rimport json\\r\\rimport requests\\r\\rimport shutil\\r\\rimport boto3\\r\\rimport stat\\r\\rdatasetid_param = os.environ['datasetId']\\rorg_param = os.environ['org']\\r\\r\\rdef getdatasetconfig(dataset_id:str, organization:str):\\r\\r        '''\\r\\r        call ai-plat api to get dataset config\\r\\r        return {dataset_config}\\r\\r        '''  \\r\\r        try:\\r            api_referer=os.environ[\\""API_URL\\""]\\r            url = f\\""{api_referer}/api/aip/services/fetchDatasetDetails/{dataset_id}/{organization}\\""\\r\\r            headers = {\\r\\r            'access-token': os.environ.get(\\""app_access_token\\""),\\r\\r            'Project':'2'\\r\\r            }\\r\\r            response = requests.request(\\""GET\\"", url, headers=headers, verify=False)\\r\\r            dataset_config = json.loads(response.text)\\r\\r            return dataset_config\\r\\r        except Exception as e:\\r\\r            print('Exception in getdatasetconfig as: ', e)\\r\\r            raise e\\r\\rdef get_keyconfig(organization:str):\\r\\r    try: \\r        api_referer=os.environ.get(\\""API_URL\\"")\\r\\r        url = f\\""{api_referer}/api/aip/service/v1/datasources/all?org={organization}\\""\\r\\r        headers = {\\r\\r        'Project': '2',\\r\\r        'access-token': os.environ.get(\\""app_access_token\\""),\\r\\r        }\\r\\r        response = requests.request(\\""GET\\"", url, headers=headers, verify=False)\\r\\r        key_config = json.loads(response.text)\\r\\r        return key_config\\r\\r    except Exception as e:\\r\\r        print('Exception in get_keyconfig as: ', e)\\r\\r        raise e\\r\\r \\r\\r\\r\\rdef s3_download_data(end_point_url,access_key,secret_key,bucket, obj_key, local_path):\\r\\r    \\""\\""\\""\\r\\r    Download a folder from S3 to a local path.\\r\\r    \\""\\""\\""\\r\\r    session = boto3.session.Session()\\r\\r    s3c = session.client(\\r\\r        aws_access_key_id=access_key,\\r\\r        aws_secret_access_key=secret_key,\\r\\r        endpoint_url=end_point_url,\\r\\r        service_name=\\""s3\\"",\\r\\r        use_ssl=False,\\r\\r    )    \\r\\r    resource = boto3.resource(\\r\\r        aws_access_key_id=access_key,\\r\\r        aws_secret_access_key=secret_key,\\r\\r        endpoint_url=end_point_url,\\r\\r        service_name=\\""s3\\"",\\r\\r        use_ssl=False,\\r        )\\r    # List all objects in the folder\\r\\r    response = s3c.list_objects_v2(Bucket=bucket, Prefix=obj_key)\\r\\r    objects = response.get('Contents', [])\\r\\r    for obj in objects:\\r\\r        key = obj['Key']\\r        print(\\""Downloading file: \\"", key)\\r        file_path = os.path.join(local_path, key)\\r        try:\\r            if not os.path.exists(os.path.dirname(file_path)):\\r                os.makedirs(os.path.dirname(file_path))\\r            if not obj.get('Key').endswith('/'):\\r                resource.meta.client.download_file(bucket, obj.get('Key'), file_path)\\r                print(f\\""Downloaded {key} to {file_path}\\"")\\r        except PermissionError as e:\\r            print(f\\""PermissionError: {e} - Skipping {key}\\"")    \\r\\rdef DatasetExtractor():    #python-script Data\\r\\r    #get dataset configurations \\r\\r    datasetcofig = getdatasetconfig(dataset_id=datasetid_param, organization=org_param)   \\r\\r    dataset_type = datasetcofig['datasource']['type']  \\r\\r    print(\\""dataset_type\\"",dataset_type)\\r\\r    if dataset_type == 'S3':\\r\\r        connection_dict = json.loads(datasetcofig['datasource']['connectionDetails'])\\r        secret_key= connection_dict['secretKey']\\r        os.environ['AWS_SECRET_ACCESS_KEY'] = secret_key\\r        access_key = connection_dict['accessKey']\\r        os.environ['AWS_ACCESS_KEY_ID'] = access_key\\r        region = connection_dict['Region']\\r        os.environ['AWS_REGION'] = region\\r        url = connection_dict['url']\\r        os.environ['AWS_ENDPOINT_URL'] = url\\r\\r        print(connection_dict)\\r\\r        print(\\""Fetched Connection Details\\"")\\r\\r        s3_access_key = connection_dict['accessKey']\\r\\r        s3_secret_key = connection_dict['secretKey']\\r\\r        s3_end_point_url = connection_dict['url'] \\r\\r        attribute = json.loads(datasetcofig['attributes'])\\r\\r        bucket = attribute['bucket']               \\r        os.environ['Bucket_Name'] = bucket\\r        path = attribute['path']   \\r\\r        obj_key = attribute['object']  \\r\\r        key = f'{path}/{obj_key}'\\r\\r        local_path = r\\""C:\\\\github\\\\data\\""\\r\\r        def on_rm_error(func, path, exc_info):\\r\\r            if not os.access(path, os.W_OK):\\r\\r                os.chmod(path, stat.S_IWUSR)\\r\\r                func(path)\\r\\r            else:\\r\\r                raise\\r\\r        if os.path.exists(local_path):\\r\\r            shutil.rmtree(local_path, onerror=on_rm_error)\\r\\r        if not os.path.exists(local_path):\\r\\r            os.makedirs(local_path)\\r\\r        os.listdir(local_path)\\r\\r        s3_download_data(end_point_url = s3_end_point_url, access_key = s3_access_key, secret_key=s3_secret_key, bucket = bucket, obj_key = key, local_path = local_path)\\r\\r    elif dataset_type == 'GIT':  \\r\\r        connection_dict = json.loads(datasetcofig['datasource']['connectionDetails'])\\r\\r        bucketname= connection_dict.get('bucketname')\\r        \\r        os.environ['Bucket_Name'] = bucketname\\r\\r        bucketPath = connection_dict.get('bucketPath')\\r\\r        attribute=json.loads(datasetcofig['attributes'])\\r\\r        url=attribute['url']\\r\\r        repo_name=url.split('/')[-1].replace('.git','')\\r        \\r        if bucketPath != \\""\\"":\\r            key= bucketPath + '/' + repo_name\\r        else:\\r             key= repo_name\\r\\r        s3ConnectionId= connection_dict['datasource']\\r\\r        response = get_keyconfig(organization=org_param)\\r\\r        for i in response:\\r\\r            if i.get('name') == s3ConnectionId:\\r\\r                connection_dict = json.loads(i.get('connectionDetails'))\\r\\r                secret_key= connection_dict['secretKey']\\r                os.environ['AWS_SECRET_ACCESS_KEY'] = secret_key\\r                access_key = connection_dict['accessKey']\\r                os.environ['AWS_ACCESS_KEY_ID'] = access_key\\r                region = connection_dict['Region']\\r                os.environ['AWS_REGION'] = region\\r                url = connection_dict['url']\\r                os.environ['AWS_ENDPOINT_URL'] = url\\r\\r                print(secret_key, access_key, region, url)\\r\\r        local_path = r\\""C:\\\\github\\\\data\\""\\r\\r        def on_rm_error(func, path, exc_info):\\r\\r            if not os.access(path, os.W_OK):\\r\\r                os.chmod(path, stat.S_IWUSR)\\r\\r                func(path)\\r\\r            else:\\r\\r                raise\\r\\r        if os.path.exists(local_path):\\r\\r            shutil.rmtree(local_path, onerror=on_rm_error)\\r\\r        if not os.path.exists(local_path):\\r\\r            os.makedirs(local_path)\\r\\r        print(os.listdir(local_path),\\""****************\\"")\\r\\r        s3_download_data(end_point_url = url, access_key = access_key, secret_key=secret_key, bucket = bucketname, obj_key = key, local_path = local_path)\\r        \\r        print(os.listdir(local_path),\\""****************\\"")\\r        \\r    return local_path""]}]}],""pipeline_attributes"":[{""name"":""storageType"",""value"":""s3""},{""name"":""usedSecrets"",""value"":""app_access_token""},{""name"":""usedSecrets"",""value"":""app_openai_api_key""},{""name"":""usedSecrets"",""value"":""app_openai_api_base""},{""name"":""usedSecrets"",""value"":""Transcribe_url""},{""name"":""usedSecrets"",""value"":""app_itgateway_client_id""},{""name"":""usedSecrets"",""value"":""app_itgateway_client_secret""},{""name"":""usedSecrets"",""value"":""app_itgateway_scope""},{""name"":""usedSecrets"",""value"":""itgateway_grant_type""},{""name"":""usedSecrets"",""value"":""itgateway_token_url""}],""environment"":[{""name"":""no_proxy"",""value"":""victlpth5-04,10.82.53.110,infyaiplat.ad.infosys.com,leap,leap2:7000""},{""name"":""proxy"",""value"":""http://blrproxy.ad.infosys.com:80""},{""name"":""API_URL"",""value"":""https://victlpth5-04:9876""}],""default_runtime"":""{\\""dsAlias\\"":\\""VICTCPAST-29\\"",\\""dsName\\"":\\""LEOVCTCP49890\\"",\\""type\\"":\\""REMOTE\\""}""}","admin","Codesummarization","2024-12-20 11:35:08","LEOCDSMR12593","leo1311","DragNDropLite","68",\N,"pipeline",NULL,"\0","0"
